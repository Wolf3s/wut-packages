diff --git a/CMakeLists.txt b/CMakeLists.txt
index b38a8bbc1..013dab9ee 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -237,8 +237,13 @@ if(USE_GCC OR USE_CLANG OR USE_INTELCC OR USE_QCC)
   set(OPT_DEF_GCC_ATOMICS ON)
 endif()
 
+if(WIIU)
+  # Prefer coreinit atomics on Wii U due to a hardware bug in load-exclusive and store-exclusive instructions
+  set(OPT_DEF_GCC_ATOMICS OFF)
+endif()
+
 # Default option knobs
-if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS)
+if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS OR WIIU)
   set(OPT_DEF_LIBC ON)
 endif()
 
@@ -350,7 +355,7 @@ if(EMSCRIPTEN)
   set(SDL_CPUINFO_ENABLED_BY_DEFAULT OFF)
 endif()
 
-if(VITA OR PSP OR PS2 OR N3DS)
+if(VITA OR PSP OR PS2 OR N3DS OR WIIU)
   set(SDL_SHARED_ENABLED_BY_DEFAULT OFF)
   set(SDL_LOADSO_ENABLED_BY_DEFAULT OFF)
 endif()
@@ -840,7 +845,7 @@ if(SDL_ASSEMBLY)
 
     check_include_file("immintrin.h" HAVE_IMMINTRIN_H)
 
-    if(SDL_ALTIVEC)
+    if(SDL_ALTIVEC AND NOT WIIU)
       set(CMAKE_REQUIRED_FLAGS "-maltivec")
       check_c_source_compiles("
           #include <altivec.h>
@@ -2883,6 +2888,46 @@ elseif(N3DS)
     endif()
     list(APPEND EXTRA_LIBS ${lib})
   endforeach()
+elseif(WIIU)
+  if(SDL_AUDIO)
+    set(SDL_AUDIO_DRIVER_WIIU 1)
+    file(GLOB WIIU_AUDIO_SOURCES ${SDL2_SOURCE_DIR}/src/audio/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_AUDIO_SOURCES})
+    set(HAVE_SDL_AUDIO TRUE)
+  endif()
+
+  if(SDL_JOYSTICK)
+    set(SDL_JOYSTICK_WIIU 1)
+    file(GLOB WIIU_JOYSTICK_SOURCES ${SDL2_SOURCE_DIR}/src/joystick/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_JOYSTICK_SOURCES})
+    set(HAVE_SDL_JOYSTICK TRUE)
+  endif()
+
+  if(SDL_THREADS)
+    set(SDL_THREAD_WIIU 1)
+    file(GLOB WIIU_THREAD_SOURCES ${SDL2_SOURCE_DIR}/src/thread/generic/SDL_systls.c ${SDL2_SOURCE_DIR}/src/thread/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_THREAD_SOURCES})
+    set(HAVE_SDL_THREADS TRUE)
+  endif()
+
+  if(SDL_TIMERS)
+    set(SDL_TIMER_WIIU 1)
+    file(GLOB WIIU_TIMER_SOURCES ${SDL2_SOURCE_DIR}/src/timer/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_TIMER_SOURCES})
+    set(HAVE_SDL_TIMERS TRUE)
+  endif()
+
+  if(SDL_VIDEO)
+    set(SDL_VIDEO_DRIVER_WIIU 1)
+    set(SDL_VIDEO_RENDER_WIIU 1)
+    file(GLOB WIIU_VIDEO_SOURCES ${SDL2_SOURCE_DIR}/src/video/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_VIDEO_SOURCES})
+    set(HAVE_SDL_VIDEO TRUE)
+  endif()
+
+  list(APPEND EXTRA_LIBS
+      wut
+    )
 endif()
 
 if(HAVE_VULKAN AND NOT SDL_LOADSO)
diff --git a/README.md b/README.md
index fa7f7ba0b..d1719bb6f 100644
--- a/README.md
+++ b/README.md
@@ -1,17 +1,17 @@
-
-# Simple DirectMedia Layer (SDL) Version 2.0
-
-https://www.libsdl.org/
-
-Simple DirectMedia Layer is a cross-platform development library designed
-to provide low level access to audio, keyboard, mouse, joystick, and graphics
-hardware via OpenGL and Direct3D. It is used by video playback software,
-emulators, and popular games including Valve's award winning catalog
-and many Humble Bundle games.
-
-More extensive documentation is available in the docs directory, starting
-with README.md
-
-Enjoy!
-
-Sam Lantinga (slouken@libsdl.org)
+
+# Simple DirectMedia Layer (SDL) Version 2.0
+
+https://www.libsdl.org/
+
+Simple DirectMedia Layer is a cross-platform development library designed
+to provide low level access to audio, keyboard, mouse, joystick, and graphics
+hardware via OpenGL and Direct3D. It is used by video playback software,
+emulators, and popular games including Valve's award winning catalog
+and many Humble Bundle games.
+
+More extensive documentation is available in the docs directory, starting
+with README.md
+
+Enjoy!
+
+Sam Lantinga (slouken@libsdl.org)
diff --git a/docs/README-wiiu.md b/docs/README-wiiu.md
new file mode 100644
index 000000000..3a697c56f
--- /dev/null
+++ b/docs/README-wiiu.md
@@ -0,0 +1,21 @@
+Wii U
+=======
+SDL port for the Nintendo Wii U
+
+Credit to
+* @rw-r-r-0644 and @QuarkTheAwesome for the initial Wii U port
+* @GaryOderNichts
+
+Building
+--------
+To build for the Wii U, make sure you have wut and wiiu-cmake installed and run:
+```
+   /opt/devkitpro/portlibs/wiiu/bin/powerpc-eabi-cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$DEVKITPRO/portlibs/wiiu
+   cmake --build build
+   cmake --install build
+```
+
+
+Notes
+-----
+* TODO
diff --git a/docs/README.md b/docs/README.md
index 6813f75fb..cd60e860c 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -49,6 +49,7 @@ More documentation and FAQs are available online at [the wiki](http://wiki.libsd
 - [WinRT](README-winrt.md)
 - [PSVita](README-vita.md)
 - [Nokia N-Gage](README-ngage.md)
+- [Wii U](README-wiiu.md)
 
 If you need help with the library, or just want to discuss SDL related
 issues, you can join the [SDL Discourse](https://discourse.libsdl.org/),
diff --git a/include/SDL_atomic.h b/include/SDL_atomic.h
index 1dd816a38..26b5fd2ef 100644
--- a/include/SDL_atomic.h
+++ b/include/SDL_atomic.h
@@ -230,6 +230,10 @@ typedef void (*SDL_KernelMemoryBarrierFunc)();
 #include <mbarrier.h>
 #define SDL_MemoryBarrierRelease()  __machine_rel_barrier()
 #define SDL_MemoryBarrierAcquire()  __machine_acq_barrier()
+#elif defined(__WIIU__)
+#include <coreinit/cache.h>
+#define SDL_MemoryBarrierRelease()  OSMemoryBarrier()
+#define SDL_MemoryBarrierAcquire()  OSMemoryBarrier()
 #else
 /* This is correct for the x86 and x64 CPUs, and we'll expand this over time. */
 #define SDL_MemoryBarrierRelease()  SDL_CompilerBarrier()
@@ -242,7 +246,7 @@ typedef void (*SDL_KernelMemoryBarrierFunc)();
     #define SDL_CPUPauseInstruction() __asm__ __volatile__("pause\n")  /* Some assemblers can't do REP NOP, so go with PAUSE. */
 #elif (defined(__arm__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7) || defined(__aarch64__)
     #define SDL_CPUPauseInstruction() __asm__ __volatile__("yield" ::: "memory")
-#elif (defined(__powerpc__) || defined(__powerpc64__))
+#elif (defined(__powerpc__) || defined(__powerpc64__) || defined(__WIIU__))
     #define SDL_CPUPauseInstruction() __asm__ __volatile__("or 27,27,27");
 #elif defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))
     #define SDL_CPUPauseInstruction() _mm_pause()  /* this is actually "rep nop" and not a SIMD instruction. No inline asm in MSVC x86-64! */
diff --git a/include/SDL_config.h.cmake b/include/SDL_config.h.cmake
index 35923d020..ab5b33274 100644
--- a/include/SDL_config.h.cmake
+++ b/include/SDL_config.h.cmake
@@ -329,6 +329,7 @@
 #cmakedefine SDL_AUDIO_DRIVER_PSP @SDL_AUDIO_DRIVER_PSP@
 #cmakedefine SDL_AUDIO_DRIVER_PS2 @SDL_AUDIO_DRIVER_PS2@
 #cmakedefine SDL_AUDIO_DRIVER_N3DS @SDL_AUDIO_DRIVER_N3DS@
+#cmakedefine SDL_AUDIO_DRIVER_WIIU @SDL_AUDIO_DRIVER_WIIU@
 
 /* Enable various input drivers */
 #cmakedefine SDL_INPUT_LINUXEV @SDL_INPUT_LINUXEV@
@@ -355,6 +356,7 @@
 #cmakedefine SDL_JOYSTICK_PSP @SDL_JOYSTICK_PSP@
 #cmakedefine SDL_JOYSTICK_PS2 @SDL_JOYSTICK_PS2@
 #cmakedefine SDL_JOYSTICK_N3DS @SDL_JOYSTICK_N3DS@
+#cmakedefine SDL_JOYSTICK_WIIU @SDL_JOYSTICK_WIIU@
 #cmakedefine SDL_HAPTIC_DUMMY @SDL_HAPTIC_DUMMY@
 #cmakedefine SDL_HAPTIC_LINUX @SDL_HAPTIC_LINUX@
 #cmakedefine SDL_HAPTIC_IOKIT @SDL_HAPTIC_IOKIT@
@@ -390,6 +392,7 @@
 #cmakedefine SDL_THREAD_PSP @SDL_THREAD_PSP@
 #cmakedefine SDL_THREAD_PS2 @SDL_THREAD_PS2@
 #cmakedefine SDL_THREAD_N3DS @SDL_THREAD_N3DS@
+#cmakedefine SDL_THREAD_WIIU @SDL_THREAD_WIIU@
 
 /* Enable various timer systems */
 #cmakedefine SDL_TIMER_HAIKU @SDL_TIMER_HAIKU@
@@ -401,6 +404,7 @@
 #cmakedefine SDL_TIMER_PSP @SDL_TIMER_PSP@
 #cmakedefine SDL_TIMER_PS2 @SDL_TIMER_PS2@
 #cmakedefine SDL_TIMER_N3DS @SDL_TIMER_N3DS@
+#cmakedefine SDL_TIMER_WIIU @SDL_TIMER_WIIU@
 
 /* Enable various video drivers */
 #cmakedefine SDL_VIDEO_DRIVER_ANDROID @SDL_VIDEO_DRIVER_ANDROID@
@@ -423,6 +427,7 @@
 #cmakedefine SDL_VIDEO_DRIVER_RISCOS @SDL_VIDEO_DRIVER_RISCOS@
 #cmakedefine SDL_VIDEO_DRIVER_PSP @SDL_VIDEO_DRIVER_PSP@
 #cmakedefine SDL_VIDEO_DRIVER_PS2 @SDL_VIDEO_DRIVER_PS2@
+#cmakedefine SDL_VIDEO_DRIVER_WIIU @SDL_VIDEO_DRIVER_WIIU@
 
 #cmakedefine SDL_VIDEO_DRIVER_KMSDRM @SDL_VIDEO_DRIVER_KMSDRM@
 #cmakedefine SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC @SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC@
@@ -467,6 +472,7 @@
 #cmakedefine SDL_VIDEO_RENDER_VITA_GXM @SDL_VIDEO_RENDER_VITA_GXM@
 #cmakedefine SDL_VIDEO_RENDER_PS2 @SDL_VIDEO_RENDER_PS2@
 #cmakedefine SDL_VIDEO_RENDER_PSP @SDL_VIDEO_RENDER_PSP@
+#cmakedefine SDL_VIDEO_RENDER_WIIU @SDL_VIDEO_RENDER_WIIU@
 
 /* Enable OpenGL support */
 #cmakedefine SDL_VIDEO_OPENGL @SDL_VIDEO_OPENGL@
diff --git a/include/SDL_endian.h b/include/SDL_endian.h
index 71bc06729..94a790378 100644
--- a/include/SDL_endian.h
+++ b/include/SDL_endian.h
@@ -79,7 +79,7 @@ _m_prefetch(void *__P)
     defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \
     (defined(__MIPS__) && defined(__MIPSEB__)) || \
     defined(__ppc__) || defined(__POWERPC__) || defined(__powerpc__) || defined(__PPC__) || \
-    defined(__sparc__)
+    defined(__sparc__) || defined(_BIG_ENDIAN) || (__BIG_ENDIAN__ == 1)
 #define SDL_BYTEORDER   SDL_BIG_ENDIAN
 #else
 #define SDL_BYTEORDER   SDL_LIL_ENDIAN
diff --git a/include/SDL_platform.h b/include/SDL_platform.h
index d2a7e052d..262e1c37f 100644
--- a/include/SDL_platform.h
+++ b/include/SDL_platform.h
@@ -200,6 +200,10 @@
 #if defined(PS2)
 #define __PS2__ 1
 #endif
+#if defined(__WIIU__)
+#undef __WIIU__
+#define __WIIU__ 1
+#endif
 
 /* The NACL compiler defines __native_client__ and __pnacl__
  * Ref: http://www.chromium.org/nativeclient/pnacl/stability-of-the-pnacl-bitcode-abi
diff --git a/include/SDL_test_common.h b/include/SDL_test_common.h
index 6de63cad6..76c6c6c8d 100644
--- a/include/SDL_test_common.h
+++ b/include/SDL_test_common.h
@@ -40,6 +40,9 @@
 #elif defined(__VITA__)
 #define DEFAULT_WINDOW_WIDTH  960
 #define DEFAULT_WINDOW_HEIGHT 544
+#elif defined(__WIIU__)
+#define DEFAULT_WINDOW_WIDTH  1280
+#define DEFAULT_WINDOW_HEIGHT 720
 #else
 #define DEFAULT_WINDOW_WIDTH  640
 #define DEFAULT_WINDOW_HEIGHT 480
diff --git a/include/SDL_video.h b/include/SDL_video.h
index c8b2d7a0d..a0e403941 100644
--- a/include/SDL_video.h
+++ b/include/SDL_video.h
@@ -124,6 +124,8 @@ typedef enum
     SDL_WINDOW_TOOLTIP          = 0x00040000,   /**< window should be treated as a tooltip */
     SDL_WINDOW_POPUP_MENU       = 0x00080000,   /**< window should be treated as a popup menu */
     SDL_WINDOW_KEYBOARD_GRABBED = 0x00100000,   /**< window has grabbed keyboard input */
+    SDL_WINDOW_WIIU_GAMEPAD_ONLY = 0x01000000,      /**< Wii U: window must be drawn only on the Gamepad */
+    SDL_WINDOW_WIIU_TV_ONLY      = 0x02000000,      /**< Wii U: window must be drawn only on the TV */
     SDL_WINDOW_VULKAN           = 0x10000000,   /**< window usable for Vulkan surface */
     SDL_WINDOW_METAL            = 0x20000000,   /**< window usable for Metal view */
 
diff --git a/src/SDL.c b/src/SDL.c
index 56049adf0..66ab88ab1 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -610,6 +610,8 @@ const char *SDL_GetPlatform(void)
     return "Nokia N-Gage";
 #elif __3DS__
     return "Nintendo 3DS";
+#elif __WIIU__
+    return "Wii U";
 #else
     return "Unknown (see SDL_platform.h)";
 #endif
diff --git a/src/SDL_log.c b/src/SDL_log.c
index ab6e7c2cb..41461c96e 100644
--- a/src/SDL_log.c
+++ b/src/SDL_log.c
@@ -39,6 +39,10 @@
 #include <android/log.h>
 #endif
 
+#if defined(__WIIU__)
+#include <coreinit/debug.h>
+#endif
+
 #include "stdlib/SDL_vacopy.h"
 
 /* The size of the stack buffer to use for rendering log messages. */
@@ -449,6 +453,10 @@ static void SDLCALL SDL_LogOutput(void *userdata, int category, SDL_LogPriority
         SDL_NSLog(SDL_priority_prefixes[priority], message);
         return;
     }
+#elif defined(__WIIU__)
+    {
+        OSReport("SDL: %s: %s\n", SDL_priority_prefixes[priority], message);
+    }
 #elif defined(__PSP__) || defined(__PS2__)
     {
         FILE *pFile;
diff --git a/src/atomic/SDL_atomic.c b/src/atomic/SDL_atomic.c
index 4e10d52db..0a3c85dd2 100644
--- a/src/atomic/SDL_atomic.c
+++ b/src/atomic/SDL_atomic.c
@@ -35,6 +35,10 @@
 #include <atomic.h>
 #endif
 
+#if defined(__WIIU__)
+#include <coreinit/atomic.h>
+#endif
+
 /* The __atomic_load_n() intrinsic showed up in different times for different compilers. */
 #if defined(__clang__)
 #if __has_builtin(__atomic_load_n) || defined(HAVE_GCC_ATOMICS)
@@ -45,9 +49,9 @@
 #endif
 #endif
 #elif defined(__GNUC__)
-#if (__GNUC__ >= 5)
-#define HAVE_ATOMIC_LOAD_N 1
-#endif
+#   if (__GNUC__ >= 5) && defined(HAVE_GCC_ATOMICS)
+#     define HAVE_ATOMIC_LOAD_N 1
+#   endif
 #endif
 
 /* *INDENT-OFF* */ /* clang-format off */
@@ -102,7 +106,7 @@ extern __inline int _SDL_xadd_watcom(volatile int *a, int v);
   Contributed by Bob Pendleton, bob@pendleton.com
 */
 
-#if !defined(HAVE_MSC_ATOMICS) && !defined(HAVE_GCC_ATOMICS) && !defined(__MACOSX__) && !defined(__SOLARIS__) && !defined(HAVE_WATCOM_ATOMICS)
+#if !defined(HAVE_MSC_ATOMICS) && !defined(HAVE_GCC_ATOMICS) && !defined(__MACOSX__) && !defined(__SOLARIS__) && !defined(HAVE_WATCOM_ATOMICS) && !defined(__WIIU__)
 #define EMULATE_CAS 1
 #endif
 
@@ -131,6 +135,8 @@ SDL_bool SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval)
     return _InterlockedCompareExchange((long *)&a->value, (long)newval, (long)oldval) == (long)oldval;
 #elif defined(HAVE_WATCOM_ATOMICS)
     return (SDL_bool)_SDL_cmpxchg_watcom(&a->value, newval, oldval);
+#elif defined(__WIIU__)
+    return OSCompareAndSwapAtomic((volatile uint32_t *)&a->value, (uint32_t)oldval, (uint32_t)newval);
 #elif defined(HAVE_GCC_ATOMICS)
     return (SDL_bool) __sync_bool_compare_and_swap(&a->value, oldval, newval);
 #elif defined(__MACOSX__)  /* this is deprecated in 10.12 sdk; favor gcc atomics. */
@@ -159,6 +165,8 @@ SDL_bool SDL_AtomicCASPtr(void **a, void *oldval, void *newval)
     return _InterlockedCompareExchangePointer(a, newval, oldval) == oldval;
 #elif defined(HAVE_WATCOM_ATOMICS)
     return (SDL_bool)_SDL_cmpxchg_watcom((int *)a, (long)newval, (long)oldval);
+#elif defined(__WIIU__)
+    return OSCompareAndSwapAtomic((volatile uint32_t *)a, (uint32_t)oldval, (uint32_t)newval);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_bool_compare_and_swap(a, oldval, newval);
 #elif defined(__MACOSX__) && defined(__LP64__)  /* this is deprecated in 10.12 sdk; favor gcc atomics. */
@@ -190,6 +198,8 @@ int SDL_AtomicSet(SDL_atomic_t *a, int v)
     return _InterlockedExchange((long *)&a->value, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return _SDL_xchg_watcom(&a->value, v);
+#elif defined(__WIIU__)
+    return (int) OSSwapAtomic((volatile uint32_t *)&a->value, (uint32_t)v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_lock_test_and_set(&a->value, v);
 #elif defined(__SOLARIS__)
@@ -209,6 +219,8 @@ void *SDL_AtomicSetPtr(void **a, void *v)
     return _InterlockedExchangePointer(a, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return (void *)_SDL_xchg_watcom((int *)a, (long)v);
+#elif defined(__WIIU__)
+    return (void *) OSSwapAtomic((volatile uint32_t *)a, (uint32_t)v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_lock_test_and_set(a, v);
 #elif defined(__SOLARIS__)
@@ -229,6 +241,8 @@ int SDL_AtomicAdd(SDL_atomic_t *a, int v)
     return _InterlockedExchangeAdd((long *)&a->value, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return _SDL_xadd_watcom(&a->value, v);
+#elif defined(__WIIU__)
+    return OSAddAtomic((volatile int32_t *)&a->value, v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_fetch_and_add(&a->value, v);
 #elif defined(__SOLARIS__)
diff --git a/src/atomic/SDL_spinlock.c b/src/atomic/SDL_spinlock.c
index 9fd3e6167..4fdc1024c 100644
--- a/src/atomic/SDL_spinlock.c
+++ b/src/atomic/SDL_spinlock.c
@@ -36,6 +36,11 @@
 #include <unixlib/local.h>
 #endif
 
+#if defined(__WIIU__)
+#include <coreinit/cache.h>
+#include <coreinit/atomic.h>
+#endif
+
 #if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))
 #include <xmmintrin.h>
 #endif
@@ -163,6 +168,9 @@ SDL_bool SDL_AtomicTryLock(SDL_SpinLock *lock)
         EIntr();
     }
     return res;
+#elif defined(__WIIU__)
+    return OSCompareAndSwapAtomic((volatile uint32_t *)lock, 0u, 1u);
+
 #else
 #error Please implement for your platform.
     return SDL_FALSE;
@@ -205,6 +213,10 @@ void SDL_AtomicUnlock(SDL_SpinLock *lock)
     *lock = 0;
     membar_producer();
 
+#elif defined(__WIIU__)
+    *lock = 0;
+    OSMemoryBarrier();
+
 #else
     *lock = 0;
 #endif
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 60242e60a..936404d95 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -123,6 +123,9 @@ static const AudioBootStrap *const bootstrap[] = {
 #if SDL_AUDIO_DRIVER_OS2
     &OS2AUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_WIIU
+    &WIIUAUDIO_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_DISK
     &DISKAUDIO_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index c755d4341..052e2cd65 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -209,6 +209,7 @@ extern AudioBootStrap VITAAUD_bootstrap;
 extern AudioBootStrap N3DSAUDIO_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
 extern AudioBootStrap OS2AUDIO_bootstrap;
+extern AudioBootStrap WIIUAUDIO_bootstrap;
 
 #endif /* SDL_sysaudio_h_ */
 
diff --git a/src/audio/wiiu/SDL_wiiuaudio.c b/src/audio/wiiu/SDL_wiiuaudio.c
new file mode 100644
index 000000000..e6f128915
--- /dev/null
+++ b/src/audio/wiiu/SDL_wiiuaudio.c
@@ -0,0 +1,425 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_AUDIO_DRIVER_WIIU
+
+#include <stdio.h>
+#include <malloc.h>
+
+#include "SDL_audio.h"
+#include "SDL_error.h"
+#include "SDL_timer.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiodev_c.h"
+#include "../SDL_sysaudio.h"
+#include "SDL_wiiuaudio.h"
+#include "SDL_wiiuaudio_mix.h"
+
+#include <sndcore2/core.h>
+#include <sndcore2/voice.h>
+#include <sndcore2/drcvs.h>
+#include <coreinit/core.h>
+#include <coreinit/cache.h>
+#include <coreinit/thread.h>
+#include <coreinit/time.h>
+#include <coreinit/memorymap.h>
+
+#define WIIUAUDIO_DRIVER_NAME "wiiu"
+
+#define AX_MAIN_AFFINITY OS_THREAD_ATTRIB_AFFINITY_CPU1
+
+static void _WIIUAUDIO_framecallback();
+static SDL_AudioDevice* cb_this;
+#define cb_hidden cb_this->hidden
+
+/*  Some helpers for AX-related math */
+/*  Absolute address to an AXVoiceOffsets offset */
+#define calc_ax_offset(offs, addr) (((void*)addr - offs.data) \
+    / sizeof_sample(offs))
+
+#define sizeof_sample(offs) (offs.dataType == AX_VOICE_FORMAT_LPCM8 ? 1 : 2)
+
+/*  +1, but never goes above NUM_BUFFERS */
+#define next_id(id) (id + 1) % NUM_BUFFERS
+
+static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
+    int ret = 0;
+    AXVoiceOffsets offs;
+    AXVoiceVeData vol = {
+        .volume = 0x8000,
+    };
+    uint32_t old_affinity;
+    float srcratio;
+    Uint8* mixbuf = NULL;
+    uint32_t mixbuf_allocation_count = 0;
+    Uint8* mixbuf_allocations[32];
+
+    this->hidden = (struct SDL_PrivateAudioData*)SDL_malloc(sizeof(*this->hidden));
+    if (this->hidden == NULL) {
+        return SDL_OutOfMemory();
+    }
+
+    SDL_zerop(this->hidden);
+
+/*  We *must not* change cores when setting stuff up */
+    old_affinity = OSGetThreadAffinity(OSGetCurrentThread());
+    OSSetThreadAffinity(OSGetCurrentThread(), AX_MAIN_AFFINITY);
+
+/*  Take a quick aside to init the wiiu audio */
+    if (!AXIsInit()) {
+    /*  Init the AX audio engine */
+        AXInitParams initparams = {
+            .renderer = AX_INIT_RENDERER_48KHZ,
+            .pipeline = AX_INIT_PIPELINE_SINGLE,
+        };
+        AXInitWithParams(&initparams);
+    } else printf("DEBUG: AX already up?\n");
+
+    if (this->spec.channels < 1) this->spec.channels = 1;
+    if (this->spec.channels > WIIU_MAX_VALID_CHANNELS)
+        this->spec.channels = WIIU_MAX_VALID_CHANNELS;
+
+/*  Force wiiu-compatible audio formats.
+    TODO verify - unsigned or signed? */
+    switch (SDL_AUDIO_BITSIZE(this->spec.format)) {
+        case 8:
+        /*  TODO 8-bit audio sounds broken */
+            /*this->spec.format = AUDIO_S8;
+            break;*/
+        case 16:
+        default:
+            this->spec.format = AUDIO_S16MSB;
+            break;
+    }
+
+    //TODO maybe round this->spec.samples up even when >?
+    //maybe even force at least 2* so we get more frame callbacks to think
+    if (this->spec.samples < AXGetInputSamplesPerFrame()) {
+        this->spec.samples = AXGetInputSamplesPerFrame();
+    }
+
+/*  We changed channels and samples, so recalculate the spec */
+    SDL_CalculateAudioSpec(&this->spec);
+
+/*  Allocate buffers for double-buffering and samples.
+    Make sure the entire mixbuf is in a 512MiB block for the DSP to be accessible. */
+    for (int i = 0; i < 32; i++) {
+        Uint32 physStart, physEnd;
+        mixbuf = memalign(0x40, this->spec.size * NUM_BUFFERS);
+        if (!mixbuf) {
+            break;
+        }
+
+        physStart = OSEffectiveToPhysical((uint32_t) mixbuf) & 0x1fffffff;
+        physEnd = physStart + this->spec.size * NUM_BUFFERS;
+        if ((physEnd & 0xe0000000) == 0) {
+            break;
+        }
+
+        mixbuf_allocations[mixbuf_allocation_count] = mixbuf;
+        mixbuf_allocation_count++;
+        mixbuf = NULL;
+    }
+
+/*  Free the failed attempts */
+    while (mixbuf_allocation_count--) {
+        free(mixbuf_allocations[mixbuf_allocation_count]);
+    }
+
+    if (!mixbuf) {
+        printf("Couldn't allocate mix buffer\n");
+        ret = SDL_OutOfMemory();
+        goto end;
+    }
+
+    memset(mixbuf, 0, this->spec.size * NUM_BUFFERS);
+    DCStoreRange(mixbuf, this->spec.size * NUM_BUFFERS);
+
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        this->hidden->mixbufs[i] = mixbuf + this->spec.size * i;
+    }
+
+/*  Allocate a scratch buffer for deinterleaving operations */
+    this->hidden->deintvbuf = SDL_malloc(this->spec.size);
+    if (this->hidden->deintvbuf == NULL) {
+        AXQuit();
+        printf("DEBUG: Couldn't allocate deinterleave buffer");
+        ret = SDL_SetError("Couldn't allocate deinterleave buffer");
+        goto end;
+    }
+
+
+    for (int i = 0; i < this->spec.channels; i++) {
+    /*  Get a voice, top priority */
+        this->hidden->voice[i] = AXAcquireVoice(31, NULL, NULL);
+        if (!this->hidden->voice[i]) {
+            AXQuit();
+            printf("DEBUG: couldn't get voice\n");
+            ret = SDL_OutOfMemory();
+            goto end;
+        }
+
+    /*  Start messing with it */
+        AXVoiceBegin(this->hidden->voice[i]);
+        AXSetVoiceType(this->hidden->voice[i], 0);
+
+    /*  Set the voice's volume. */
+        AXSetVoiceVe(this->hidden->voice[i], &vol);
+        switch (this->spec.channels) {
+            case 1: /* mono */ {
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_DRC, 0, mono_mix[i]);
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_TV, 0, mono_mix[i]);
+            } break;
+            case 2: /* stereo */ {
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_DRC, 0, stereo_mix[i]);
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_TV, 0, stereo_mix[i]);
+            } break;
+        }
+
+    /*  Set the samplerate conversion ratio
+        <source sample rate> / <target sample rate> */
+        srcratio = (float)this->spec.freq / (float)AXGetInputSamplesPerSec();
+        AXSetVoiceSrcRatio(this->hidden->voice[i], srcratio);
+        AXSetVoiceSrcType(this->hidden->voice[i], AX_VOICE_SRC_TYPE_LINEAR);
+
+    /*  Set up the offsets for the first mixbuf */
+        switch (SDL_AUDIO_BITSIZE(this->spec.format)) {
+            case 8:
+                offs.dataType = AX_VOICE_FORMAT_LPCM8;
+                offs.endOffset = this->spec.samples;
+                break;
+            case 16:
+            default:
+                offs.dataType = AX_VOICE_FORMAT_LPCM16;
+                offs.endOffset = this->spec.samples;
+                break;
+        }
+        offs.loopingEnabled = AX_VOICE_LOOP_ENABLED;
+        offs.loopOffset = 0;
+        offs.currentOffset = 0;
+
+        if (offs.dataType == AX_VOICE_FORMAT_LPCM8) {
+            offs.data = this->hidden->mixbufs[0]
+                + this->spec.samples * i * sizeof(Uint8);
+        } else if (offs.dataType == AX_VOICE_FORMAT_LPCM16) {
+            offs.data = this->hidden->mixbufs[0]
+                + this->spec.samples * i * sizeof(Uint16);
+        }
+        AXSetVoiceOffsets(this->hidden->voice[i], &offs);
+
+    /*  Set the last good loopcount */
+        this->hidden->last_loopcount = AXGetVoiceLoopCount(this->hidden->voice[i]);
+
+    /*  Offsets are set for playing the first mixbuf, so we should render the second */
+        this->hidden->playingid = 0;
+        this->hidden->renderingid = 1;
+
+    /*  Start playing. */
+        AXSetVoiceState(this->hidden->voice[i], AX_VOICE_STATE_PLAYING);
+
+    /*  Okay, we're good */
+        AXVoiceEnd(this->hidden->voice[i]);
+    }
+
+    cb_this = this; //wish there was a better way
+    AXRegisterAppFrameCallback(_WIIUAUDIO_framecallback);
+
+end: ;
+/*  Put the thread affinity back to normal - we won't call any more AX funcs */
+    OSSetThreadAffinity(OSGetCurrentThread(), old_affinity);
+    return ret;
+}
+
+/*  Called every 3ms before a frame of audio is rendered. Keep it fast! */
+static void _WIIUAUDIO_framecallback() {
+    int playing_buffer = -1;
+    AXVoiceOffsets offs[6];
+    void* endaddr;
+
+    for (int i = 0; i < cb_this->spec.channels; i++) {
+        AXGetVoiceOffsets(cb_hidden->voice[i], &offs[i]);
+    }
+
+/*  Figure out which buffer is being played by the hardware */
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        void* buf = cb_hidden->mixbufs[i];
+        uint32_t startOffset = calc_ax_offset(offs[0], buf);
+        uint32_t endOffset = startOffset + cb_this->spec.samples;
+
+    /*  NOTE endOffset definitely needs to be <= (AX plays the sample at
+        endOffset), dunno about startOffset */
+        if (offs[0].currentOffset >= startOffset &&
+            offs[0].currentOffset <= endOffset) {
+            playing_buffer = i;
+            break;
+        }
+    }
+
+    if (playing_buffer < 0 || playing_buffer >= NUM_BUFFERS) {
+    /*  UM */
+    /*  Uncomment for craploads of debug info */
+        /*printf("bad buffer %d\n" "|> %08X, %08X-%08X\n" \
+            "0: xxxxxxxx, %08X-%08X (%08X@%08X)\n" \
+            "1: xxxxxxxx, %08X-%08X (%08X@%08X)\n", \
+            playing_buffer, offs.currentOffset, offs.loopOffset, offs.endOffset,
+            calc_ax_offset(offs, (void*)cb_hidden->mixbufs[0]),
+                calc_ax_offset(offs, (void*)cb_hidden->mixbufs[0] + cb_this->spec.size),
+                cb_this->spec.size, (void*)cb_hidden->mixbufs[0],
+            calc_ax_offset(offs, (void*)cb_hidden->mixbufs[1]),
+                calc_ax_offset(offs, (void*)cb_hidden->mixbufs[1] + cb_this->spec.size),
+                cb_this->spec.size, (void*)cb_hidden->mixbufs[1]);*/
+        printf("DEBUG: Playing an invalid buffer? This is not a good sign.\n");
+        playing_buffer = 0;
+    }
+
+/*  Make sure playingid is in sync with the hardware */
+    cb_hidden->playingid = playing_buffer;
+
+/*  Make sure the end offset is correct for the playing buffer */
+    for (int i = 0; i < cb_this->spec.channels; i++) {
+    /*  Calculate end address, aka start of the next (i+1) channel's buffer */
+        endaddr = cb_hidden->mixbufs[cb_hidden->playingid] +
+            (cb_this->spec.samples * sizeof_sample(offs[i]) * (i + 1));
+
+    /*  Trial end error to try and limit popping */
+        endaddr -= 2;
+
+        AXSetVoiceEndOffset(
+            cb_hidden->voice[i],
+            calc_ax_offset(offs[i], endaddr)
+        );
+
+    /*  The next buffer is good to go, set the loop offset */
+        if (cb_hidden->renderingid != next_id(cb_hidden->playingid)) {
+        /*  Calculate start address for this channel's buffer */
+            void* loopaddr = cb_hidden->mixbufs[next_id(cb_hidden->playingid)] +
+                (cb_this->spec.samples * sizeof_sample(offs[i]) * i);
+
+            AXSetVoiceLoopOffset(cb_hidden->voice[i], calc_ax_offset(offs[i], loopaddr));
+    /*  Otherwise, make sure the loop offset is correct for the playing buffer */
+        } else {
+            void* loopaddr = cb_hidden->mixbufs[cb_hidden->playingid] +
+                (cb_this->spec.samples * sizeof_sample(offs[i]) * i);
+
+            AXSetVoiceLoopOffset(cb_hidden->voice[i], calc_ax_offset(offs[i], loopaddr));
+        }
+    }
+}
+
+static void WIIUAUDIO_PlayDevice(_THIS) {
+/*  Deinterleave stereo audio */
+    switch (SDL_AUDIO_BITSIZE(this->spec.format)) {
+        case 8: {
+            Uint8* samples = (Uint8*)this->hidden->mixbufs[this->hidden->renderingid];
+            Uint8* deintv = (Uint8*)this->hidden->deintvbuf;
+
+            /* Store the samples in a separate deinterleaved buffer */
+            for (int ch = 0; ch < this->spec.channels; ch++) {
+                for (int i = 0; i < this->spec.samples; i++) {
+                    deintv[this->spec.samples * ch + i] = samples[i * this->spec.channels + ch];
+                }
+            }
+        } break;
+        case 16: {
+            Uint16* samples = (Uint16*)this->hidden->mixbufs[this->hidden->renderingid];
+            Uint16* deintv = (Uint16*)this->hidden->deintvbuf;
+
+            /* Store the samples in a separate deinterleaved buffer */
+            for (int ch = 0; ch < this->spec.channels; ch++) {
+                for (int i = 0; i < this->spec.samples; i++) {
+                    deintv[this->spec.samples * ch + i] = samples[i * this->spec.channels + ch];
+                }
+            }
+        } break;
+        default: {} break;
+    }
+
+/*  Copy the deinterleaved buffer to the mixing buffer */
+    memcpy(
+        this->hidden->mixbufs[this->hidden->renderingid],
+        this->hidden->deintvbuf,
+        this->spec.size
+    );
+/*  Comment this out for broken-record mode ;3 */
+    DCStoreRange(this->hidden->mixbufs[this->hidden->renderingid], this->spec.size);
+/*  Signal we're no longer rendering this buffer, AX callback will notice later */
+    this->hidden->renderingid = next_id(this->hidden->renderingid);
+}
+
+static void WIIUAUDIO_WaitDevice(_THIS) {
+/*  TODO use real thread sync stuff */
+    while (SDL_AtomicGet(&this->enabled) && this->hidden->renderingid == this->hidden->playingid) {
+        OSSleepTicks(OSMillisecondsToTicks(3));
+    }
+}
+
+static Uint8* WIIUAUDIO_GetDeviceBuf(_THIS) {
+/*  SDL will write audio samples into this buffer */
+    return this->hidden->mixbufs[this->hidden->renderingid];
+}
+
+static void WIIUAUDIO_CloseDevice(_THIS) {
+    if (AXIsInit()) {
+        AXDeregisterAppFrameCallback(_WIIUAUDIO_framecallback);
+        for (int i = 0; i < SIZEOF_ARR(this->hidden->voice); i++) {
+            if (this->hidden->voice[i]) {
+                AXFreeVoice(this->hidden->voice[i]);
+                this->hidden->voice[i] = NULL;
+            }
+        }
+        AXQuit();
+    }
+    if (this->hidden->mixbufs[0]) free(this->hidden->mixbufs[0]);
+    if (this->hidden->deintvbuf) SDL_free(this->hidden->deintvbuf);
+    SDL_free(this->hidden);
+}
+
+static void WIIUAUDIO_ThreadInit(_THIS) {
+/*  Bump our thread's priority a bit */
+    OSThread* currentThread = OSGetCurrentThread();
+    int32_t priority = OSGetThreadPriority(currentThread);
+    priority -= 1;
+    OSSetThreadPriority(currentThread, priority);
+}
+
+static SDL_bool WIIUAUDIO_Init(SDL_AudioDriverImpl* impl) {
+    impl->OpenDevice = WIIUAUDIO_OpenDevice;
+    impl->PlayDevice = WIIUAUDIO_PlayDevice;
+    impl->WaitDevice = WIIUAUDIO_WaitDevice;
+    impl->GetDeviceBuf = WIIUAUDIO_GetDeviceBuf;
+    impl->CloseDevice = WIIUAUDIO_CloseDevice;
+    impl->ThreadInit = WIIUAUDIO_ThreadInit;
+
+    impl->OnlyHasDefaultOutputDevice = SDL_TRUE;
+
+    return SDL_TRUE;
+}
+
+AudioBootStrap WIIUAUDIO_bootstrap = {
+    WIIUAUDIO_DRIVER_NAME, "Wii U AX Audio Driver", WIIUAUDIO_Init, 0,
+};
+
+#endif //SDL_AUDIO_DRIVER_WIIU
diff --git a/src/audio/wiiu/SDL_wiiuaudio.h b/src/audio/wiiu/SDL_wiiuaudio.h
new file mode 100644
index 000000000..41cb4a48b
--- /dev/null
+++ b/src/audio/wiiu/SDL_wiiuaudio.h
@@ -0,0 +1,51 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_wiiuaudio_h_
+#define SDL_wiiuaudio_h_
+
+#include "../SDL_sysaudio.h"
+
+#include <sndcore2/voice.h>
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS   SDL_AudioDevice *this
+
+#define NUM_BUFFERS 2
+
+#define SIZEOF_ARR(arr) (sizeof(arr) / sizeof(arr[0]))
+
+struct SDL_PrivateAudioData {
+    /* 6 possible voices for 6 channels */
+    AXVoice* voice[6];
+    /* The raw allocated mixing buffer. */
+    Uint8   *rawbuf;
+    /* Individual mixing buffers. */
+    Uint8   *mixbufs[NUM_BUFFERS];
+    /* Deinterleaving buffer. */
+    Uint8   *deintvbuf;
+
+    int renderingid;
+    int playingid;
+    uint32_t last_loopcount;
+};
+
+#endif /* SDL_wiiuaudio_h_ */
diff --git a/src/audio/wiiu/SDL_wiiuaudio_mix.h b/src/audio/wiiu/SDL_wiiuaudio_mix.h
new file mode 100644
index 000000000..57b661c89
--- /dev/null
+++ b/src/audio/wiiu/SDL_wiiuaudio_mix.h
@@ -0,0 +1,65 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_wiiuaudio_mix_h_
+#define SDL_wiiuaudio_mix_h_
+
+/* Some defines to help make the code below more readable */
+#define AX_VOICE(x) x
+#define AX_CHANNEL_LEFT 0
+#define AX_CHANNEL_RIGHT 1
+#define AX_BUS_MASTER 0
+
+/* TODO: AXGetDeviceChannelCount. For now we'll use Decaf's values.
+ * According to Decaf, the TV has 6 channels and the gamepad has 4. We set up
+ * both arrays with 6, the Gamepad callbacks just won't use the whole buffer. */
+#define AX_NUM_CHANNELS 6
+
+static AXVoiceDeviceMixData stereo_mix[2 /* voices */][AX_NUM_CHANNELS] = {
+    [AX_VOICE(0)] = {
+        [AX_CHANNEL_LEFT] = {
+            .bus = {
+                [AX_BUS_MASTER] = { .volume = 0x8000 },
+            }
+        },
+    },
+    [AX_VOICE(1)] = {
+        [AX_CHANNEL_RIGHT] = {
+            .bus = {
+                [AX_BUS_MASTER] = { .volume = 0x8000 },
+            }
+        },
+    },
+};
+static AXVoiceDeviceMixData mono_mix[1 /* voice */][AX_NUM_CHANNELS] = {
+    [AX_VOICE(0)] = {
+        [AX_CHANNEL_LEFT] = { .bus = {
+            [AX_BUS_MASTER] = { .volume = 0x8000 },
+        }},
+        [AX_CHANNEL_RIGHT] = { .bus = {
+            [AX_BUS_MASTER] = { .volume = 0x8000 },
+        }},
+    },
+};
+
+#define WIIU_MAX_VALID_CHANNELS 2
+
+#endif //SDL_wiiuaudio_mix_h_
diff --git a/src/dynapi/SDL_dynapi.h b/src/dynapi/SDL_dynapi.h
index 99ca08008..d684b5fed 100644
--- a/src/dynapi/SDL_dynapi.h
+++ b/src/dynapi/SDL_dynapi.h
@@ -59,6 +59,8 @@
 #define SDL_DYNAMIC_API 0
 #elif defined(__riscos__) && __riscos__ /* probably not useful on RISC OS, since dlopen() can't be used when using static linking. */
 #define SDL_DYNAMIC_API 0
+#elif defined(__WIIU__) && __WIIU__
+#define SDL_DYNAMIC_API 0
 #elif defined(__clang_analyzer__) || defined(SDL_THREAD_SAFETY_ANALYSIS)
 #define SDL_DYNAMIC_API 0 /* Turn off for static analysis, so reports are more clear. */
 #elif defined(__VITA__)
diff --git a/src/joystick/SDL_gamecontrollerdb.h b/src/joystick/SDL_gamecontrollerdb.h
index f926c1612..cc5c44474 100644
--- a/src/joystick/SDL_gamecontrollerdb.h
+++ b/src/joystick/SDL_gamecontrollerdb.h
@@ -991,6 +991,16 @@ static const char *s_ControllerMappings[] = {
 #endif
 #if SDL_JOYSTICK_N3DS
     "000000004e696e74656e646f20334400,Nintendo 3DS,crc:3210,a:b0,b:b1,back:b2,dpdown:b7,dpleft:b5,dpright:b4,dpup:b6,leftshoulder:b9,lefttrigger:b14,leftx:a0,lefty:a1,rightshoulder:b8,righttrigger:b15,rightx:a2,righty:a3,start:b3,x:b10,y:b11,",
+#endif
+#if defined(SDL_JOYSTICK_WIIU)
+    "0000000057696920552047616d657000,Wii U Gamepad,crc:e2e7,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920552047616d657000,Wii U Gamepad,crc:e2e7,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920552050726f204300,Wii U Pro Controller,crc:e45c,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920552050726f204300,Wii U Pro Controller,crc:e45c,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920436c617373696300,Wii Classic Controller,crc:5ef0,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920436c617373696300,Wii Classic Controller,crc:5ef0,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "00000000576969204e756e6368756b00,Wii Remote + Nunchuk,crc:bce1,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,",
+    "000000005769692052656d6f74650000,Wii Remote,crc:1d69,a:b7,b:b6,back:b11,dpdown:b12,dpleft:b13,dpright:b15,dpup:b14,start:b10,x:b1,y:b0,",
 #endif
     "hidapi,*,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
     NULL
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index 834e83d99..2bc162aee 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -84,7 +84,10 @@ static SDL_JoystickDriver *SDL_joystick_drivers[] = {
 #ifdef SDL_JOYSTICK_HAIKU
     &SDL_HAIKU_JoystickDriver,
 #endif
-#ifdef SDL_JOYSTICK_USBHID /* !!! FIXME: "USBHID" is a generic name, and doubly-confusing with HIDAPI next to it. This is the *BSD interface, rename this. */
+#ifdef SDL_JOYSTICK_WIIU
+    &SDL_WIIU_JoystickDriver,
+#endif
+#ifdef SDL_JOYSTICK_USBHID  /* !!! FIXME: "USBHID" is a generic name, and doubly-confusing with HIDAPI next to it. This is the *BSD interface, rename this. */
     &SDL_BSD_JoystickDriver,
 #endif
 #ifdef SDL_JOYSTICK_OS2
diff --git a/src/joystick/SDL_sysjoystick.h b/src/joystick/SDL_sysjoystick.h
index a93fa662c..4f0c0df77 100644
--- a/src/joystick/SDL_sysjoystick.h
+++ b/src/joystick/SDL_sysjoystick.h
@@ -249,6 +249,7 @@ extern SDL_JoystickDriver SDL_PS2_JoystickDriver;
 extern SDL_JoystickDriver SDL_PSP_JoystickDriver;
 extern SDL_JoystickDriver SDL_VITA_JoystickDriver;
 extern SDL_JoystickDriver SDL_N3DS_JoystickDriver;
+extern SDL_JoystickDriver SDL_WIIU_JoystickDriver;
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
new file mode 100644
index 000000000..312921101
--- /dev/null
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -0,0 +1,647 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2019 Ash Logan <ash@heyquark.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+	 claim that you wrote the original software. If you use this software
+	 in a product, an acknowledgment in the product documentation would be
+	 appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+	 misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_JOYSTICK_WIIU
+
+#include <vpad/input.h>
+#include <padscore/wpad.h>
+#include <padscore/kpad.h>
+#include <coreinit/debug.h>
+
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+#include "../../events/SDL_touch_c.h"
+
+#include "SDL_log.h"
+#include "SDL_assert.h"
+#include "SDL_events.h"
+
+#include "SDL_wiiujoystick.h"
+
+//index with device_index, get WIIU_DEVICE*
+static int deviceMap[MAX_CONTROLLERS];
+//index with device_index, get SDL_JoystickID
+static SDL_JoystickID instanceMap[MAX_CONTROLLERS];
+static WPADExtensionType lastKnownExts[WIIU_NUM_WPADS];
+
+static int WIIU_JoystickInit(void);
+static int WIIU_JoystickGetCount(void);
+static void WIIU_JoystickDetect(void);
+static const char *WIIU_JoystickGetDeviceName(int device_index);
+static int WIIU_JoystickGetDevicePlayerIndex(int device_index);
+static void WIIU_JoystickSetDevicePlayerIndex(int device_index, int player_index);
+static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index);
+static SDL_JoystickID WIIU_JoystickGetDeviceInstanceID(int device_index);
+static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index);
+static int WIIU_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble);
+static int WIIU_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble);
+static Uint32 WIIU_JoystickGetCapabilities(SDL_Joystick *joystick);
+static int WIIU_JoystickSetLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue);
+static int WIIU_JoystickSendEffect(SDL_Joystick *joystick, const void *data, int size);
+static int WIIU_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled);
+static void WIIU_JoystickUpdate(SDL_Joystick *joystick);
+static void WIIU_JoystickClose(SDL_Joystick *joystick);
+static void WIIU_JoystickQuit(void);
+static SDL_bool WIIU_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping * out);
+
+static int WIIU_GetDeviceForIndex(int device_index) {
+	return deviceMap[device_index];
+}
+static int WIIU_GetIndexForDevice(int wiiu_device) {
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		if (deviceMap[i] == wiiu_device) return i;
+	}
+	return -1;
+}
+
+static int WIIU_GetNextDeviceIndex() {
+	return WIIU_GetIndexForDevice(WIIU_DEVICE_INVALID);
+}
+
+static SDL_JoystickID WIIU_GetInstForIndex(int device_index) {
+	if (device_index == -1) return -1;
+	return instanceMap[device_index];
+}
+static SDL_JoystickID WIIU_GetInstForDevice(int wiiu_device) {
+	int device_index = WIIU_GetIndexForDevice(wiiu_device);
+	return WIIU_GetInstForIndex(device_index);
+}
+static int WIIU_GetDeviceForInst(SDL_JoystickID instance) {
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		if (instanceMap[i] == instance) return deviceMap[i];
+	}
+	return WIIU_DEVICE_INVALID;
+}
+
+static void WIIU_RemoveDevice(int wiiu_device) {
+	int device_index = WIIU_GetIndexForDevice(wiiu_device);
+	if (device_index == -1) return;
+	/* Move all the other controllers back, so all device_indexes are valid */
+	for (int i = device_index; i < MAX_CONTROLLERS; i++) {
+		if (i + 1 < MAX_CONTROLLERS) {
+			deviceMap[i] = deviceMap[i + 1];
+			instanceMap[i] = instanceMap[i + 1];
+		} else {
+			deviceMap[i] = -1;
+			instanceMap[i] = -1;
+		}
+	}
+}
+
+/* Function to scan the system for joysticks.
+ * Joystick 0 should be the system default joystick.
+ * This function should return 0, or -1 on an unrecoverable error.
+ */
+static int WIIU_JoystickInit(void)
+{
+	VPADInit();
+	KPADInit();
+	WPADEnableURCC(1);
+
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		deviceMap[i] = WIIU_DEVICE_INVALID;
+		instanceMap[i] = -1;
+	}
+	WIIU_JoystickDetect();
+	return 0;
+}
+
+/* Function to return the number of joystick devices plugged in right now */
+static int WIIU_JoystickGetCount(void)
+{
+	return WIIU_GetNextDeviceIndex();
+}
+
+/* Function to cause any queued joystick insertions to be processed */
+static void WIIU_JoystickDetect(void)
+{
+/*	Make sure there are no dangling instances or device indexes
+ 	These checks *should* be unneccesary, remove once battle-tested */
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		if (deviceMap[i] == WIIU_DEVICE_INVALID && instanceMap[i] != -1) {
+
+			SDL_LogWarn(SDL_LOG_CATEGORY_INPUT,
+				"WiiU device_index %d dangling instance %d!\n",
+				i, instanceMap[i]
+			);
+			/* Make sure that joystick actually got removed */
+			SDL_PrivateJoystickRemoved(instanceMap[i]);
+			instanceMap[i] = -1;
+		}
+		if (deviceMap[i] != WIIU_DEVICE_INVALID && instanceMap[i] == -1) {
+			SDL_LogWarn(SDL_LOG_CATEGORY_INPUT,
+				"WiiU device_index %d assigned to %d, but has no instance!\n",
+				i, deviceMap[i]
+			);
+			instanceMap[i] = -1;
+		}
+	}
+/*	Check if we are missing the WiiU Gamepad and try to connect it
+	if the gamepad is disconnected that's handled in SDL_UpdateJoystick */
+	if (WIIU_GetIndexForDevice(WIIU_DEVICE_GAMEPAD) == -1) {
+	/*	Try and detect a gamepad */
+		VPADStatus status;
+		VPADReadError err;
+		VPADRead(VPAD_CHAN_0, &status, 1, &err);
+		if (err == VPAD_READ_SUCCESS || err == VPAD_READ_NO_SAMPLES) {
+		/*	We have a gamepad! Assign a device index and instance ID. */
+			int device_index = WIIU_GetNextDeviceIndex();
+			if (device_index != -1) {
+			/*	Save its device index */
+				deviceMap[device_index] = WIIU_DEVICE_GAMEPAD;
+				instanceMap[device_index] = SDL_GetNextJoystickInstanceID();
+				SDL_PrivateJoystickAdded(instanceMap[device_index]);
+				SDL_LogInfo(SDL_LOG_CATEGORY_INPUT,
+					"WiiU: Detected Gamepad, assigned device %d/instance %d\n",
+					device_index, instanceMap[device_index]);
+			}
+		}
+	}
+	/* Check for WPAD/KPAD controllers */
+	for (int i = 0; i < WIIU_NUM_WPADS; i++) {
+		WPADExtensionType ext;
+		int wiiu_device = WIIU_DEVICE_WPAD(i);
+		int ret = WPADProbe(WIIU_WPAD_CHAN(wiiu_device), &ext);
+		if (ret == 0) { //controller connected
+			/* Is this already connected? */
+			if (WIIU_GetIndexForDevice(wiiu_device) == -1) {
+				/* No! Let's add it. */
+				int device_index = WIIU_GetNextDeviceIndex();
+				if (device_index != -1) {
+				/*	Save its device index */
+					deviceMap[device_index] = WIIU_DEVICE_WPAD(i);
+					instanceMap[device_index] = SDL_GetNextJoystickInstanceID();
+				/*	Save its extension controller */
+					lastKnownExts[WIIU_WPAD_CHAN(wiiu_device)] = ext;
+					SDL_PrivateJoystickAdded(instanceMap[device_index]);
+					SDL_LogInfo(SDL_LOG_CATEGORY_INPUT,
+						"WiiU: Detected WPAD, assigned device %d/instance %d\n",
+						device_index, instanceMap[device_index]);
+				}
+			} else if (ext != lastKnownExts[WIIU_WPAD_CHAN(wiiu_device)]) {
+				/* If this controller has changed extensions, we should
+				disconnect and reconnect it. */
+				SDL_JoystickID instance = WIIU_GetInstForDevice(wiiu_device);
+				/* Yes! We should disconnect it. */
+				SDL_PrivateJoystickRemoved(instance);
+				/* Unlink device_index, instance_id */
+				WIIU_RemoveDevice(wiiu_device);
+			}
+		} else if (ret == -1) { //no controller
+			/* Is this controller connected? */
+			if (WIIU_GetIndexForDevice(wiiu_device) != -1) {
+				SDL_JoystickID instance = WIIU_GetInstForDevice(wiiu_device);
+				/* Yes! We should disconnect it. */
+				SDL_PrivateJoystickRemoved(instance);
+				/* Unlink device_index, instance_id */
+				WIIU_RemoveDevice(wiiu_device);
+			}
+		} // otherwise do nothing (-2: pairing)
+	}
+}
+
+/* Function to get the device-dependent name of a joystick */
+static const char *WIIU_JoystickGetDeviceName(int device_index)
+{
+	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+	/* Gamepad */
+	if (wiiu_device == WIIU_DEVICE_GAMEPAD) {
+		return "WiiU Gamepad";
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(0)) {
+		RETURN_WPAD_NAME(1, lastKnownExts[0]);
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(1)) {
+		RETURN_WPAD_NAME(2, lastKnownExts[1]);
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(2)) {
+		RETURN_WPAD_NAME(3, lastKnownExts[2]);
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(3)) {
+		RETURN_WPAD_NAME(4, lastKnownExts[3]);
+	}
+
+	return "Unknown";
+}
+
+static const char * WIIU_JoystickGetDevicePath(int device_index)
+{
+    return NULL;
+}
+
+/* Function to get the player index of a joystick */
+static int WIIU_JoystickGetDevicePlayerIndex(int device_index)
+{
+	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+	switch (wiiu_device) {
+		case WIIU_DEVICE_GAMEPAD: { return 0; }
+		case WIIU_DEVICE_WPAD(0): { return 1; }
+		case WIIU_DEVICE_WPAD(1): { return 2; }
+		case WIIU_DEVICE_WPAD(2): { return 3; }
+		case WIIU_DEVICE_WPAD(3): { return 4; }
+		default: { return -1; }
+	}
+
+}
+
+static void WIIU_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
+/* Function to return the stable GUID for a plugged in device */
+static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index)
+{
+	SDL_JoystickGUID guid;
+	const int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+
+	switch (wiiu_device)
+	{
+		case WIIU_DEVICE_GAMEPAD:
+			guid = SDL_CreateJoystickGUIDForName("Wii U Gamepad");
+			break;
+
+		case WIIU_DEVICE_WPAD(0):
+		case WIIU_DEVICE_WPAD(1):
+		case WIIU_DEVICE_WPAD(2):
+		case WIIU_DEVICE_WPAD(3):
+			switch (lastKnownExts[WIIU_WPAD_CHAN(wiiu_device)])
+			{
+				case WPAD_EXT_CORE:
+				case WPAD_EXT_MPLUS:
+				default:
+					guid = SDL_CreateJoystickGUIDForName("Wii Remote");
+					break;
+
+				case WPAD_EXT_NUNCHUK:
+				case WPAD_EXT_MPLUS_NUNCHUK:
+					guid = SDL_CreateJoystickGUIDForName("Wii Nunchuk");
+					break;
+
+				case WPAD_EXT_CLASSIC:
+				case WPAD_EXT_MPLUS_CLASSIC:
+					guid = SDL_CreateJoystickGUIDForName("Wii Classic Controller");
+					break;
+
+				case WPAD_EXT_PRO_CONTROLLER:
+					guid = SDL_CreateJoystickGUIDForName("Wii U Pro Controller");
+					break;
+			}
+
+			break;
+
+		default:
+			/* Unknown */
+			/* The iPhone backend for SDL2 does this if it can't get a GUID. */
+			SDL_zero(guid);
+			break;
+	}
+
+	return guid;
+}
+
+/* Function to get the current instance id of the joystick located at device_index */
+static SDL_JoystickID WIIU_JoystickGetDeviceInstanceID(int device_index)
+{
+	return WIIU_GetInstForIndex(device_index);
+}
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the device index.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+	switch (wiiu_device) {
+		case WIIU_DEVICE_GAMEPAD: {
+			SDL_AddTouch(0, SDL_TOUCH_DEVICE_DIRECT, "WiiU Gamepad Touchscreen");
+			joystick->nbuttons = SIZEOF_ARR(vpad_button_map);
+			joystick->naxes = 4;
+			joystick->nhats = 0;
+
+			break;
+		}
+		case WIIU_DEVICE_WPAD(0):
+		case WIIU_DEVICE_WPAD(1):
+		case WIIU_DEVICE_WPAD(2):
+		case WIIU_DEVICE_WPAD(3): {
+			WPADExtensionType ext;
+			int ret = WPADProbe(WIIU_WPAD_CHAN(wiiu_device), &ext);
+			if (ret != 0) {
+				SDL_LogWarn(SDL_LOG_CATEGORY_INPUT,
+					"WiiU_JoystickOpen: WPAD device %d failed probe!",
+					WIIU_WPAD_CHAN(wiiu_device));
+				return -1;
+			}
+
+			switch (ext) {
+				case WPAD_EXT_CORE:
+				case WPAD_EXT_MPLUS:
+				default: {
+					joystick->nbuttons = SIZEOF_ARR(wiimote_button_map);
+					joystick->naxes = 0;
+					joystick->nhats = 0;
+					break;
+				}
+				case WPAD_EXT_NUNCHUK:
+				case WPAD_EXT_MPLUS_NUNCHUK: {
+					joystick->nbuttons = SIZEOF_ARR(nunchuk_button_map);
+					joystick->naxes = 2;
+					joystick->nhats = 0;
+					break;
+				}
+				case WPAD_EXT_CLASSIC:
+				case WPAD_EXT_MPLUS_CLASSIC: {
+					joystick->nbuttons = SIZEOF_ARR(classic_button_map);
+					joystick->naxes = 4;
+					joystick->nhats = 0;
+					break;
+				}
+				case WPAD_EXT_PRO_CONTROLLER: {
+					joystick->nbuttons = SIZEOF_ARR(pro_button_map);
+					joystick->naxes = 4;
+					joystick->nhats = 0;
+					break;
+				}
+			}
+			break;
+		}
+	}
+
+	joystick->instance_id = WIIU_GetInstForIndex(device_index);
+	return 0;
+}
+
+/* Rumble functionality */
+static int WIIU_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble)
+{
+	/* TODO */
+	return SDL_Unsupported();
+}
+
+static int WIIU_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble)
+{
+	return SDL_Unsupported();
+}
+
+/* Capability detection */
+static Uint32 WIIU_JoystickGetCapabilities(SDL_Joystick *joystick)
+{
+	/* TODO implement supported capabilities */
+	return 0;
+}
+
+/* LED functionality */
+static int WIIU_JoystickSetLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue)
+{
+	return SDL_Unsupported();
+}
+
+/* General effects */
+static int WIIU_JoystickSendEffect(SDL_Joystick *joystick, const void *data, int size)
+{
+	return SDL_Unsupported();
+}
+
+/* Sensor functionality */
+static int WIIU_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled)
+{
+	return SDL_Unsupported();
+}
+
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+static void WIIU_JoystickUpdate(SDL_Joystick *joystick)
+{
+	int16_t x1, y1, x2, y2;
+	/* Gamepad */
+	if (joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_GAMEPAD)) {
+		static uint16_t last_touch_x = 0;
+		static uint16_t last_touch_y = 0;
+		static uint16_t last_touched = 0;
+
+		static int16_t x1_old = 0;
+		static int16_t y1_old = 0;
+		static int16_t x2_old = 0;
+		static int16_t y2_old = 0;
+
+		VPADStatus vpad;
+		VPADReadError error;
+		VPADTouchData tpdata;
+		VPADRead(VPAD_CHAN_0, &vpad, 1, &error);
+		if (error == VPAD_READ_INVALID_CONTROLLER) {
+			/* Gamepad disconnected! */
+			SDL_PrivateJoystickRemoved(joystick->instance_id);
+			/* Unlink Gamepad, device_index, instance_id */
+			WIIU_RemoveDevice(WIIU_DEVICE_GAMEPAD);
+		} else if (error != VPAD_READ_SUCCESS) {
+			return;
+		}
+
+		/* touchscreen */
+		VPADGetTPCalibratedPoint(VPAD_CHAN_0, &tpdata, &vpad.tpNormal);
+		if (tpdata.touched) {
+			if (!last_touched) {
+				/* Send an initial touch */
+				SDL_SendTouch(0, 0, NULL, SDL_TRUE,
+						(float) tpdata.x / 1280.0f,
+						(float) tpdata.y / 720.0f, 1);
+			}
+
+			/* Always send the motion */
+			SDL_SendTouchMotion(0, 0, NULL,
+					(float) tpdata.x / 1280.0f,
+					(float) tpdata.y / 720.0f, 1);
+
+			/* Update old values */
+			last_touch_x = tpdata.x;
+			last_touch_y = tpdata.y;
+			last_touched = 1;
+		} else if (last_touched) {
+			/* Finger released from screen */
+			SDL_SendTouch(0, 0, NULL, SDL_FALSE,
+					(float) last_touch_x / 1280.0f,
+					(float) last_touch_y / 720.0f, 1);
+			last_touched = 0;
+		}
+
+		/* axys */
+		x1 = (int16_t) ((vpad.leftStick.x) * 0x7ff0);
+		y1 = (int16_t) -((vpad.leftStick.y) * 0x7ff0);
+		x2 = (int16_t) ((vpad.rightStick.x) * 0x7ff0);
+		y2 = (int16_t) -((vpad.rightStick.y) * 0x7ff0);
+
+		if(x1 != x1_old) {
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			x1_old = x1;
+		}
+		if(y1 != y1_old) {
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			y1_old = y1;
+		}
+		if(x2 != x2_old) {
+			SDL_PrivateJoystickAxis(joystick, 2, x2);
+			x2_old = x2;
+		}
+		if(y2 != y2_old) {
+			SDL_PrivateJoystickAxis(joystick, 3, y2);
+			y2_old = y2;
+		}
+
+		/* buttons */
+		for(int i = 0; i < joystick->nbuttons; i++)
+			if (vpad.trigger & vpad_button_map[i])
+				SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+		for(int i = 0; i < joystick->nbuttons; i++)
+			if (vpad.release & vpad_button_map[i])
+				SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+	} else if (
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(0)) ||
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(1)) ||
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(2)) ||
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(3))) {
+		int wiiu_device = WIIU_GetDeviceForInst(joystick->instance_id);
+		WPADExtensionType ext;
+		KPADStatus kpad;
+		int32_t err;
+
+		if (WPADProbe(WIIU_WPAD_CHAN(wiiu_device), &ext) != 0) {
+			/* Do nothing, we'll catch it in Detect() */
+			return;
+		}
+
+		KPADReadEx(WIIU_WPAD_CHAN(wiiu_device), &kpad, 1, &err);
+		if (err != KPAD_ERROR_OK) return;
+
+		switch (ext) {
+		case WPAD_EXT_CORE:
+		case WPAD_EXT_MPLUS:
+		default: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.trigger & wiimote_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.release & wiimote_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+			break;
+		}
+		case WPAD_EXT_NUNCHUK:
+		case WPAD_EXT_MPLUS_NUNCHUK: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if ((kpad.trigger | (kpad.nunchuk.trigger << 16)) & nunchuk_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if ((kpad.release | (kpad.nunchuk.release << 16)) & nunchuk_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+
+			x1 = (int16_t) ((kpad.nunchuk.stick.x) * 0x7ff0);
+			y1 = (int16_t) -((kpad.nunchuk.stick.y) * 0x7ff0);
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			break;
+		}
+		case WPAD_EXT_CLASSIC:
+		case WPAD_EXT_MPLUS_CLASSIC: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.classic.trigger & classic_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.classic.release & classic_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+
+			x1 = (int16_t) ((kpad.classic.leftStick.x) * 0x7ff0);
+			y1 = (int16_t) -((kpad.classic.leftStick.y) * 0x7ff0);
+			x2 = (int16_t) ((kpad.classic.rightStick.x) * 0x7ff0);
+			y2 = (int16_t) -((kpad.classic.rightStick.y) * 0x7ff0);
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			SDL_PrivateJoystickAxis(joystick, 2, x2);
+			SDL_PrivateJoystickAxis(joystick, 3, y2);
+			break;
+		}
+		case WPAD_EXT_PRO_CONTROLLER: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.pro.trigger & pro_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.pro.release & pro_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+
+			x1 = (int16_t) ((kpad.pro.leftStick.x) * 0x7ff0);
+			y1 = (int16_t) -((kpad.pro.leftStick.y) * 0x7ff0);
+			x2 = (int16_t) ((kpad.pro.rightStick.x) * 0x7ff0);
+			y2 = (int16_t) -((kpad.pro.rightStick.y) * 0x7ff0);
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			SDL_PrivateJoystickAxis(joystick, 2, x2);
+			SDL_PrivateJoystickAxis(joystick, 3, y2);
+			break;
+		}
+		}
+	}
+}
+
+/* Function to close a joystick after use */
+static void WIIU_JoystickClose(SDL_Joystick *joystick)
+{
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+static void WIIU_JoystickQuit(void)
+{
+}
+
+/* Function to get the autodetected controller mapping; returns false if there isn't any. */
+static SDL_bool WIIU_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping * out)
+{
+	return SDL_FALSE;
+}
+
+SDL_JoystickDriver SDL_WIIU_JoystickDriver =
+{
+	WIIU_JoystickInit,
+	WIIU_JoystickGetCount,
+	WIIU_JoystickDetect,
+	WIIU_JoystickGetDeviceName,
+	WIIU_JoystickGetDevicePath,
+	WIIU_JoystickGetDevicePlayerIndex,
+	WIIU_JoystickSetDevicePlayerIndex,
+	WIIU_JoystickGetDeviceGUID,
+	WIIU_JoystickGetDeviceInstanceID,
+	WIIU_JoystickOpen,
+	WIIU_JoystickRumble,
+	WIIU_JoystickRumbleTriggers,
+	WIIU_JoystickGetCapabilities,
+	WIIU_JoystickSetLED,
+	WIIU_JoystickSendEffect,
+	WIIU_JoystickSetSensorsEnabled,
+	WIIU_JoystickUpdate,
+	WIIU_JoystickClose,
+	WIIU_JoystickQuit,
+	WIIU_JoystickGetGamepadMapping,
+};
+
+#endif
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.h b/src/joystick/wiiu/SDL_wiiujoystick.h
new file mode 100644
index 000000000..24f79ca76
--- /dev/null
+++ b/src/joystick/wiiu/SDL_wiiujoystick.h
@@ -0,0 +1,110 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <padscore/wpad.h>
+
+#define WIIU_DEVICE_INVALID (-1)
+#define WIIU_DEVICE_GAMEPAD (0)
+#define WIIU_DEVICE_WPAD(x) (x + 1)
+#define WIIU_WPAD_CHAN(device) (device - 1)
+#define WIIU_NUM_WPADS (4)
+
+#define MAX_CONTROLLERS WIIU_DEVICE_WPAD(WIIU_NUM_WPADS)
+
+#define SIZEOF_ARR(arr) (sizeof(arr) / sizeof(arr[0]))
+
+static uint32_t vpad_button_map[] =
+{
+    VPAD_BUTTON_A, VPAD_BUTTON_B, VPAD_BUTTON_X, VPAD_BUTTON_Y,
+    VPAD_BUTTON_STICK_L, VPAD_BUTTON_STICK_R,
+    VPAD_BUTTON_L, VPAD_BUTTON_R,
+    VPAD_BUTTON_ZL, VPAD_BUTTON_ZR,
+    VPAD_BUTTON_PLUS, VPAD_BUTTON_MINUS,
+    VPAD_BUTTON_LEFT, VPAD_BUTTON_UP, VPAD_BUTTON_RIGHT, VPAD_BUTTON_DOWN,
+    VPAD_STICK_L_EMULATION_LEFT, VPAD_STICK_L_EMULATION_UP, VPAD_STICK_L_EMULATION_RIGHT, VPAD_STICK_L_EMULATION_DOWN,
+    VPAD_STICK_R_EMULATION_LEFT, VPAD_STICK_R_EMULATION_UP, VPAD_STICK_R_EMULATION_RIGHT, VPAD_STICK_R_EMULATION_DOWN
+};
+
+static uint32_t wiimote_button_map[] = {
+    WPAD_BUTTON_A, WPAD_BUTTON_B, 0, 0,
+    0, 0,
+    WPAD_BUTTON_1, WPAD_BUTTON_2,
+    0, 0,
+    WPAD_BUTTON_PLUS, WPAD_BUTTON_MINUS,
+    WPAD_BUTTON_LEFT, WPAD_BUTTON_UP, WPAD_BUTTON_RIGHT, WPAD_BUTTON_DOWN,
+};
+
+static uint32_t nunchuk_button_map[] = {
+    WPAD_BUTTON_A, WPAD_BUTTON_B, WPAD_BUTTON_Z, WPAD_BUTTON_C,
+    0, 0,
+    WPAD_BUTTON_1, WPAD_BUTTON_2,
+    0, 0,
+    WPAD_BUTTON_PLUS, WPAD_BUTTON_MINUS,
+    WPAD_BUTTON_LEFT, WPAD_BUTTON_UP, WPAD_BUTTON_RIGHT, WPAD_BUTTON_DOWN,
+    WPAD_NUNCHUK_STICK_EMULATION_LEFT << 16, WPAD_NUNCHUK_STICK_EMULATION_UP << 16, WPAD_NUNCHUK_STICK_EMULATION_RIGHT << 16, WPAD_NUNCHUK_STICK_EMULATION_DOWN << 16,
+};
+
+static uint32_t classic_button_map[] = {
+    WPAD_CLASSIC_BUTTON_A, WPAD_CLASSIC_BUTTON_B, WPAD_CLASSIC_BUTTON_X,
+    WPAD_CLASSIC_BUTTON_Y,
+    0, 0,
+    WPAD_CLASSIC_BUTTON_L, WPAD_CLASSIC_BUTTON_R,
+    WPAD_CLASSIC_BUTTON_ZL, WPAD_CLASSIC_BUTTON_ZR,
+    WPAD_CLASSIC_BUTTON_PLUS, WPAD_CLASSIC_BUTTON_MINUS,
+    WPAD_CLASSIC_BUTTON_LEFT, WPAD_CLASSIC_BUTTON_UP, WPAD_CLASSIC_BUTTON_RIGHT, WPAD_CLASSIC_BUTTON_DOWN,
+    WPAD_CLASSIC_STICK_L_EMULATION_LEFT, WPAD_CLASSIC_STICK_L_EMULATION_UP, WPAD_CLASSIC_STICK_L_EMULATION_RIGHT, WPAD_CLASSIC_STICK_L_EMULATION_DOWN,
+    WPAD_CLASSIC_STICK_R_EMULATION_LEFT, WPAD_CLASSIC_STICK_R_EMULATION_UP, WPAD_CLASSIC_STICK_R_EMULATION_RIGHT, WPAD_CLASSIC_STICK_R_EMULATION_DOWN,
+};
+
+static uint32_t pro_button_map[] = {
+    WPAD_PRO_BUTTON_A, WPAD_PRO_BUTTON_B, WPAD_PRO_BUTTON_X, WPAD_PRO_BUTTON_Y,
+    WPAD_PRO_BUTTON_STICK_L, WPAD_PRO_BUTTON_STICK_R,
+    WPAD_PRO_TRIGGER_L, WPAD_PRO_TRIGGER_R,
+    WPAD_PRO_TRIGGER_ZL, WPAD_PRO_TRIGGER_ZR,
+    WPAD_PRO_BUTTON_PLUS, WPAD_PRO_BUTTON_MINUS,
+    WPAD_PRO_BUTTON_LEFT, WPAD_PRO_BUTTON_UP,
+    WPAD_PRO_BUTTON_RIGHT, WPAD_PRO_BUTTON_DOWN,
+    WPAD_PRO_STICK_L_EMULATION_LEFT, WPAD_PRO_STICK_L_EMULATION_UP,
+    WPAD_PRO_STICK_L_EMULATION_RIGHT, WPAD_PRO_STICK_L_EMULATION_DOWN,
+    WPAD_PRO_STICK_R_EMULATION_LEFT, WPAD_PRO_STICK_R_EMULATION_UP,
+    WPAD_PRO_STICK_R_EMULATION_RIGHT, WPAD_PRO_STICK_R_EMULATION_DOWN
+};
+
+#define RETURN_WPAD_NAME(chan, ext) { \
+    switch (ext) { \
+    case WPAD_EXT_CORE: \
+    case WPAD_EXT_MPLUS: \
+    default: { \
+        return "Wii Remote #" #chan; \
+    } \
+    case WPAD_EXT_NUNCHUK: \
+    case WPAD_EXT_MPLUS_NUNCHUK: { \
+        return "Wii Remote #" #chan " and Nunchuk"; \
+    } \
+    case WPAD_EXT_CLASSIC: \
+    case WPAD_EXT_MPLUS_CLASSIC: { \
+        return "Wii Classic Controller #" #chan; \
+    } \
+    case WPAD_EXT_PRO_CONTROLLER: { \
+        return "WiiU Pro Controller #" #chan; \
+    } \
+    } \
+}
diff --git a/src/libm/math_private.h b/src/libm/math_private.h
index ee67c444e..23fad187b 100644
--- a/src/libm/math_private.h
+++ b/src/libm/math_private.h
@@ -27,7 +27,7 @@
 #define libm_hidden_def(x)
 #define strong_alias(x, y)
 
-#if !defined(__HAIKU__) && !defined(__PSP__) && !defined(__3DS__) && !defined(__PS2__) /* already defined in a system header. */
+#if !defined(__HAIKU__) && !defined(__PSP__) && !defined(__3DS__) && !defined(__PS2__) && !defined(__WIIU__) /* already defined in a system header. */
 typedef unsigned int u_int32_t;
 #endif
 
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index b650c6ac4..846b97b88 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -38,8 +38,10 @@ that will crash the app. However, these apps _should_ have used
 SDL_AddEventWatch to catch SDL_APP_WILLENTERBACKGROUND events and stopped
 drawing themselves. Other platforms still draw, as the compositor can use it,
 and more importantly: drawing to render targets isn't lost. But I still think
-this should probably be removed at some point in the future.  --ryan. */
-#if defined(__IPHONEOS__) || defined(__TVOS__) || defined(__ANDROID__)
+this should probably be removed at some point in the future.  --ryan.*/
+/* Same goes for Wii U. If you draw things while not in foreground the app
+will just crash. --gary*/
+#if defined(__IPHONEOS__) || defined(__TVOS__) || defined(__ANDROID__) || defined(__WIIU__)
 #define DONT_DRAW_WHILE_HIDDEN 1
 #else
 #define DONT_DRAW_WHILE_HIDDEN 0
@@ -124,6 +126,9 @@ static const SDL_RenderDriver *render_drivers[] = {
 #if SDL_VIDEO_RENDER_VITA_GXM
     &VITA_GXM_RenderDriver,
 #endif
+#if SDL_VIDEO_RENDER_WIIU
+    &WIIU_RenderDriver,
+#endif
 #if SDL_VIDEO_RENDER_SW
     &SW_RenderDriver
 #endif
diff --git a/src/render/SDL_sysrender.h b/src/render/SDL_sysrender.h
index 36e9555bb..283fe0e88 100644
--- a/src/render/SDL_sysrender.h
+++ b/src/render/SDL_sysrender.h
@@ -307,6 +307,7 @@ extern SDL_RenderDriver PS2_RenderDriver;
 extern SDL_RenderDriver PSP_RenderDriver;
 extern SDL_RenderDriver SW_RenderDriver;
 extern SDL_RenderDriver VITA_GXM_RenderDriver;
+extern SDL_RenderDriver WIIU_RenderDriver;
 
 /* Blend mode functions */
 extern SDL_BlendFactor SDL_GetBlendModeSrcColorFactor(SDL_BlendMode blendMode);
diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
new file mode 100644
index 000000000..c046b0711
--- /dev/null
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -0,0 +1,370 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "SDL_hints.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/event.h>
+#include <gx2/swap.h>
+#include <gx2/registers.h>
+#include <gx2/state.h>
+#include <gx2r/surface.h>
+
+#include <malloc.h>
+
+SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
+{
+    SDL_Renderer *renderer;
+    WIIU_RenderData *data;
+
+    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
+    if (!renderer) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data = (WIIU_RenderData *) SDL_calloc(1, sizeof(*data));
+    if (!data) {
+        SDL_free(renderer);
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    /* Setup renderer functions */
+    renderer->WindowEvent = WIIU_SDL_WindowEvent;
+    renderer->SupportsBlendMode = WIIU_SDL_SupportsBlendMode;
+    renderer->CreateTexture = WIIU_SDL_CreateTexture;
+    renderer->UpdateTexture = WIIU_SDL_UpdateTexture;
+    renderer->LockTexture = WIIU_SDL_LockTexture;
+    renderer->UnlockTexture = WIIU_SDL_UnlockTexture;
+    renderer->SetTextureScaleMode = WIIU_SDL_SetTextureScaleMode;
+    renderer->SetRenderTarget = WIIU_SDL_SetRenderTarget;
+    renderer->QueueSetViewport = WIIU_SDL_QueueSetViewport;
+    renderer->QueueSetDrawColor = WIIU_SDL_QueueSetDrawColor;
+    renderer->QueueDrawPoints = WIIU_SDL_QueueDrawPoints;
+    renderer->QueueDrawLines = WIIU_SDL_QueueDrawLines;
+    renderer->QueueGeometry = WIIU_SDL_QueueGeometry;
+    renderer->RunCommandQueue = WIIU_SDL_RunCommandQueue;
+    renderer->RenderReadPixels = WIIU_SDL_RenderReadPixels;
+    renderer->RenderPresent = WIIU_SDL_RenderPresent;
+    renderer->DestroyTexture = WIIU_SDL_DestroyTexture;
+    renderer->DestroyRenderer = WIIU_SDL_DestroyRenderer;
+    renderer->SetVSync = WIIU_SDL_SetVSync;
+    renderer->info = WIIU_RenderDriver.info;
+    renderer->driverdata = data;
+    renderer->window = window;
+
+    WIIU_SDL_SetVSync(renderer, (flags & SDL_RENDERER_PRESENTVSYNC) != 0);
+
+    /* Prepare shaders */
+    WIIU_SDL_CreateShaders();
+
+    /* List of attibutes to free after render */
+    data->listfree[0] = NULL;
+    data->listfree[1] = NULL;
+
+    /* Setup line and point size */
+    GX2SetLineWidth(1.0f);
+    GX2SetPointSize(1.0f, 1.0f);
+
+    /* Create a fresh context state */
+    data->ctx = (GX2ContextState *) memalign(GX2_CONTEXT_STATE_ALIGNMENT, sizeof(GX2ContextState));
+    SDL_memset(data->ctx, 0, sizeof(GX2ContextState));
+    GX2SetupContextStateEx(data->ctx, TRUE);
+    GX2SetContextState(data->ctx);
+
+    /* Setup some context state options */
+    GX2SetAlphaTest(TRUE, GX2_COMPARE_FUNC_GREATER, 0.0f);
+    GX2SetDepthOnlyControl(FALSE, FALSE, GX2_COMPARE_FUNC_NEVER);
+    GX2SetCullOnlyControl(GX2_FRONT_FACE_CCW, FALSE, FALSE);
+
+    data->drawState.blendMode = SDL_BLENDMODE_INVALID;
+    data->drawState.shader = SHADER_INVALID;
+    data->drawState.projectionMatrix[3][0] = -1.0f;
+    data->drawState.projectionMatrix[3][1] = 1.0f;
+    data->drawState.projectionMatrix[3][3] = 1.0f;
+
+    /* Make a texture for the window */
+    WIIU_SDL_CreateWindowTex(renderer, window);
+
+    /* Setup colour buffer, rendering to the window */
+    WIIU_SDL_SetRenderTarget(renderer, NULL);
+
+    return renderer;
+}
+
+SDL_bool WIIU_SDL_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)
+{
+    SDL_BlendFactor srcColorFactor = SDL_GetBlendModeSrcColorFactor(blendMode);
+    SDL_BlendFactor srcAlphaFactor = SDL_GetBlendModeSrcAlphaFactor(blendMode);
+    SDL_BlendOperation colorOperation = SDL_GetBlendModeColorOperation(blendMode);
+    SDL_BlendFactor dstColorFactor = SDL_GetBlendModeDstColorFactor(blendMode);
+    SDL_BlendFactor dstAlphaFactor = SDL_GetBlendModeDstAlphaFactor(blendMode);
+    SDL_BlendOperation alphaOperation = SDL_GetBlendModeAlphaOperation(blendMode);
+
+    if (WIIU_SDL_GetBlendMode(srcColorFactor) == -1 ||
+        WIIU_SDL_GetBlendMode(srcAlphaFactor) == -1 ||
+        WIIU_SDL_GetBlendCombineMode(colorOperation) == -1 ||
+        WIIU_SDL_GetBlendMode(dstColorFactor) == -1 ||
+        WIIU_SDL_GetBlendMode(dstAlphaFactor) == -1 ||
+        WIIU_SDL_GetBlendCombineMode(alphaOperation) == -1) {
+        return SDL_FALSE;
+    }
+    return SDL_TRUE;
+}
+
+void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    const char *s_hint;
+    SDL_ScaleMode s_mode;
+
+    if (data->windowTex.driverdata) {
+        WIIU_SDL_DestroyTexture(renderer, &data->windowTex);
+        data->windowTex = (SDL_Texture) {0};
+    }
+
+    /* Setup scaling mode; this is normally handled by
+       SDL_CreateTexture/SDL_GetScaleMode, but those can't
+       be called before fully initializinig the renderer */
+    s_hint = SDL_GetHint(SDL_HINT_RENDER_SCALE_QUALITY);
+    if (!s_hint || SDL_strcasecmp(s_hint, "nearest") == 0) {
+        s_mode = SDL_ScaleModeNearest;
+    } else if (SDL_strcasecmp(s_hint, "linear") == 0) {
+        s_mode = SDL_ScaleModeLinear;
+    } else if (SDL_strcasecmp(s_hint, "best") == 0) {
+        s_mode = SDL_ScaleModeBest;
+    } else {
+        s_mode = (SDL_ScaleMode)SDL_atoi(s_hint);
+    }
+
+    /* Allocate a buffer for the window */
+    data->windowTex = (SDL_Texture) {
+        .format = SDL_PIXELFORMAT_RGBA8888,
+        .driverdata = WIIU_TEXTURE_MEM1_MAGIC,
+        .scaleMode = s_mode,
+    };
+
+    SDL_GetWindowSize(window, &data->windowTex.w, &data->windowTex.h);
+
+    /* Setup texture and color buffer for the window */
+    WIIU_SDL_CreateTexture(renderer, &data->windowTex);
+}
+
+void WIIU_SDL_DestroyWindowTex(SDL_Renderer * renderer, SDL_Window * window)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+
+    WIIU_SDL_DestroyTexture(renderer, &data->windowTex);
+}
+
+int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
+
+    /* Set window or texture as target */
+    WIIU_TextureData *tdata = (WIIU_TextureData *)((texture) ? texture->driverdata
+                                                             : data->windowTex.driverdata);
+
+    if (!videodata->hasForeground) {
+        return 0;
+    }
+
+    /* make sure we're using the correct renderer ctx */
+    GX2SetContextState(data->ctx);
+
+    /* Wait for the texture rendering to finish if it is still in use by the GPU */
+    if (WIIU_TextureInUse(data, tdata)) {
+        WIIU_TextureWaitDone(data, tdata);
+    }
+
+    /* Update context state */
+    GX2SetColorBuffer(&tdata->cbuf, GX2_RENDER_TARGET_0);
+
+    return 0;
+}
+
+void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
+
+    if (videodata->hasForeground) {
+        GX2DrawDone();
+    }
+
+    /* Free both render data queues */
+    WIIU_FreeRenderData(data, 0);
+    WIIU_FreeRenderData(data, 1);
+
+    free(data->ctx);
+
+    WIIU_SDL_DestroyShaders();
+
+    SDL_free(data);
+    SDL_free(renderer);
+}
+
+int WIIU_SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
+                              Uint32 format, void * pixels, int pitch)
+{
+    SDL_Texture* target = WIIU_GetRenderTarget(renderer);
+    WIIU_TextureData* tdata = (WIIU_TextureData*) target->driverdata;
+    Uint8 *src_image;
+    int ret;
+
+    /* NOTE: The rect is already adjusted according to the viewport by
+       SDL_RenderReadPixels */
+
+    if (rect->x < 0 || rect->x+rect->w > tdata->cbuf.surface.width ||
+        rect->y < 0 || rect->y+rect->h > tdata->cbuf.surface.height) {
+        return SDL_SetError("Tried to read outside of surface bounds");
+    }
+
+    src_image = GX2RLockSurfaceEx(&tdata->cbuf.surface, 0, GX2R_RESOURCE_LOCKED_READ_ONLY);
+
+    /* Convert and copy the pixels to target buffer */
+    ret = SDL_ConvertPixels(rect->w, rect->h, target->format,
+                            src_image + rect->y * tdata->cbuf.surface.pitch + rect->x * 4,
+                            tdata->cbuf.surface.pitch,
+                            format, pixels, pitch);
+
+    GX2RUnlockSurfaceEx(&tdata->cbuf.surface, 0, GX2R_RESOURCE_LOCKED_READ_ONLY);
+
+    return ret;
+}
+
+GX2RBuffer * WIIU_AllocRenderData(WIIU_RenderData *r, GX2RBuffer buffer)
+{
+    WIIU_RenderAllocData *rdata = SDL_malloc(sizeof(WIIU_RenderAllocData));
+
+    rdata->buffer = buffer;
+    if (!GX2RCreateBuffer(&rdata->buffer)) {
+        SDL_free(rdata);
+        return 0;
+    }
+
+    rdata->next = r->listfree[r->actlist];
+    r->listfree[r->actlist] = rdata;
+    return &rdata->buffer;
+}
+
+void WIIU_FreeRenderData(WIIU_RenderData *r, int list)
+{
+    while (r->listfree[list]) {
+        WIIU_RenderAllocData *ptr = r->listfree[list];
+        r->listfree[list] = ptr->next;
+        GX2RDestroyBufferEx(&ptr->buffer, 0);
+        SDL_free(ptr);
+    }
+}
+
+void WIIU_TextureMarkUsed(WIIU_RenderData *r, WIIU_TextureData *t)
+{
+    /* Since GX2GetLastSubmittedTimeStamp might not flush and won't return the timestamp of the
+       batch at which the texture has been used, we do +1 to act as "whichever timestamp will be done
+       next". Only adding +1 is okay, since between the point markUsed is called and the actual draw
+       submit call happenning, no other draw should be submitted. */
+    t->timestamp = GX2GetLastSubmittedTimeStamp() + 1;
+}
+
+SDL_bool WIIU_TextureInUse(WIIU_RenderData *r, WIIU_TextureData *t)
+{
+    /* If the last retired time stamp of the batch is less than the buffer timestamp,
+       the GPU might have not processed this buffer yet */
+    return GX2GetRetiredTimeStamp() < t->timestamp;
+}
+
+SDL_bool WIIU_TextureWaitDone(WIIU_RenderData *r, WIIU_TextureData *t)
+{
+    /* If the buffer has never been used, don't do anything */
+    if (t->timestamp == 0) {
+        return true;
+    }
+
+    /* Flushing here is important otherwise we might wait on a buffer that
+       hasn't even been submitted to the GPU yet */
+    GX2Flush();
+
+    /* Wait on the buffers timestamp */
+    return GX2WaitTimeStamp(t->timestamp);
+}
+
+void WIIU_FrameDone(WIIU_RenderData *r)
+{
+    /* This function will be called once all GPU calls of a frame have been submitted..
+       We'll save the last submitted frame timestamp and wait to make sure the previous
+       frame is fully drawn. Then we can free its buffers. */
+    r->lastFrameTimestamp = r->currFrameTimestamp;
+    r->currFrameTimestamp = GX2GetLastSubmittedTimeStamp();
+
+    /* Ensure the previous frame has been rendered completely */
+    if (GX2GetRetiredTimeStamp() < r->lastFrameTimestamp) {
+        GX2WaitTimeStamp(r->lastFrameTimestamp);
+    }
+
+    /* Free inactive render data, now that we're sure the GPU is no longer using it */
+    WIIU_FreeRenderData(r, !r->actlist);
+    r->actlist = !r->actlist;
+}
+
+SDL_RenderDriver WIIU_RenderDriver =
+{
+    .CreateRenderer = WIIU_SDL_CreateRenderer,
+    .info = {
+        .name = "WiiU GX2",
+        .flags = SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE,
+        .num_texture_formats = 15,
+        .texture_formats = {
+            SDL_PIXELFORMAT_RGBA8888,
+            SDL_PIXELFORMAT_RGBX8888,
+
+            SDL_PIXELFORMAT_ARGB4444,
+            SDL_PIXELFORMAT_RGBA4444,
+            SDL_PIXELFORMAT_ABGR4444,
+            SDL_PIXELFORMAT_BGRA4444,
+
+            SDL_PIXELFORMAT_ARGB1555,
+            SDL_PIXELFORMAT_ABGR1555,
+            SDL_PIXELFORMAT_RGBA5551,
+            SDL_PIXELFORMAT_BGRA5551,
+
+            SDL_PIXELFORMAT_ARGB8888,
+            SDL_PIXELFORMAT_BGRA8888,
+            SDL_PIXELFORMAT_BGRX8888,
+            SDL_PIXELFORMAT_ABGR8888,
+
+            SDL_PIXELFORMAT_ARGB2101010,
+        },
+        .max_texture_width = 0,
+        .max_texture_height = 0,
+    },
+};
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/wiiu/SDL_render_wiiu.h b/src/render/wiiu/SDL_render_wiiu.h
new file mode 100644
index 000000000..4e015ebb8
--- /dev/null
+++ b/src/render/wiiu/SDL_render_wiiu.h
@@ -0,0 +1,315 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_render_wiiu_h
+#define SDL_render_wiiu_h
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_pixels.h"
+#include "SDL_shaders_wiiu.h"
+
+#include "../../video/SDL_sysvideo.h"
+#include "../../video/wiiu/SDL_wiiuvideo.h"
+
+#include <gx2r/buffer.h>
+#include <gx2/context.h>
+#include <gx2/sampler.h>
+#include <gx2/texture.h>
+#include <gx2/surface.h>
+#include <gx2/event.h>
+#include <gx2/utils.h>
+
+/* Driver internal data structures */
+typedef struct WIIU_PixFmt WIIU_PixFmt;
+typedef struct WIIU_RenderAllocData WIIU_RenderAllocData;
+typedef struct WIIU_DrawState WIIU_DrawState;
+typedef struct WIIU_RenderData WIIU_RenderData;
+typedef struct WIIU_TextureData WIIU_TextureData;
+
+struct WIIU_PixFmt
+{
+    GX2SurfaceFormat fmt;
+    uint32_t compMap;
+};
+
+struct WIIU_RenderAllocData
+{
+    WIIU_RenderAllocData *next;
+    GX2RBuffer buffer;
+};
+
+struct WIIU_DrawState
+{
+    SDL_Texture *target;
+    SDL_Texture *texture;
+
+    SDL_Rect viewport;
+    SDL_bool viewportDirty;
+    int drawableWidth, drawableHeight;
+    float projectionMatrix[4][4];
+
+    SDL_bool cliprectEnabled;
+    SDL_bool cliprectDirty;
+    SDL_Rect cliprect;
+
+    SDL_BlendMode blendMode;
+
+    WIIU_ShaderType shader;
+};
+
+struct WIIU_RenderData
+{
+    GX2ContextState *ctx;
+    int actlist;
+    WIIU_RenderAllocData *listfree[2];
+    OSTime currFrameTimestamp;
+    OSTime lastFrameTimestamp;
+    SDL_Texture windowTex;
+    WIIU_DrawState drawState;
+};
+
+struct WIIU_TextureData
+{
+    GX2Sampler sampler;
+    GX2Texture texture;
+    GX2ColorBuffer cbuf;
+    OSTime timestamp;
+};
+
+/* Ask texture driver to allocate texture's memory from MEM1 */
+#define WIIU_TEXTURE_MEM1_MAGIC (void *)0xCAFE0001
+
+/* SDL_render API implementation */
+SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags);
+void WIIU_SDL_WindowEvent(SDL_Renderer * renderer,
+                             const SDL_WindowEvent *event);
+SDL_bool WIIU_SDL_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode);
+int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                       const SDL_Rect * rect, const void *pixels,
+                       int pitch);
+int WIIU_SDL_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                     const SDL_Rect * rect, void **pixels, int *pitch);
+void WIIU_SDL_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+void WIIU_SDL_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode);
+int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture);
+int WIIU_SDL_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand * cmd);
+int WIIU_SDL_QueueSetDrawColor(SDL_Renderer * renderer, SDL_RenderCommand * cmd);
+int WIIU_SDL_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count);
+int WIIU_SDL_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count);
+int WIIU_SDL_QueueGeometry(SDL_Renderer * renderer, SDL_RenderCommand * cmd, SDL_Texture * texture,
+        const float * xy, int xy_stride, const SDL_Color * color, int color_stride, const float * uv, int uv_stride,
+        int num_vertices, const void * indices, int num_indices, int size_indices,
+        float scale_x, float scale_y);
+int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize);
+int WIIU_SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
+                          Uint32 format, void * pixels, int pitch);
+int WIIU_SDL_SetVSync(SDL_Renderer * renderer, const int vsync);
+int WIIU_SDL_RenderPresent(SDL_Renderer * renderer);
+void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer);
+
+/* Driver internal functions */
+void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window);
+void WIIU_SDL_DestroyWindowTex(SDL_Renderer * renderer, SDL_Window * window);
+
+/* Utility/helper functions */
+GX2RBuffer * WIIU_AllocRenderData(WIIU_RenderData *r, GX2RBuffer buffer);
+void WIIU_FreeRenderData(WIIU_RenderData *r, int list);
+
+void WIIU_TextureMarkUsed(WIIU_RenderData *r, WIIU_TextureData *t);
+SDL_bool WIIU_TextureInUse(WIIU_RenderData *r, WIIU_TextureData *t);
+SDL_bool WIIU_TextureWaitDone(WIIU_RenderData *r, WIIU_TextureData *t);
+
+void WIIU_FrameDone(WIIU_RenderData *r);
+
+static inline SDL_Texture * WIIU_GetRenderTarget(SDL_Renderer* renderer)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+
+    if (renderer->target) {
+        return renderer->target;
+    }
+
+    return &data->windowTex;
+}
+
+static inline WIIU_PixFmt WIIU_SDL_GetPixFmt(Uint32 format)
+{
+    WIIU_PixFmt outFmt = { .fmt = -1, .compMap = 0 };
+
+    switch (format) {
+        /* packed16 formats: 4 bits/channel */
+        case SDL_PIXELFORMAT_ARGB4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
+            break;
+        }
+        case SDL_PIXELFORMAT_RGBA4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
+            break;
+        }
+        case SDL_PIXELFORMAT_ABGR4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_A, GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R);
+            break;
+        }
+        case SDL_PIXELFORMAT_BGRA4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
+            break;
+        }
+
+        /* packed16 formats: 5 bits/channel */
+        case SDL_PIXELFORMAT_ARGB1555: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
+            break;
+        }
+        case SDL_PIXELFORMAT_ABGR1555: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_A, GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R);
+            break;
+        }
+        case SDL_PIXELFORMAT_RGBA5551: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
+            break;
+        }
+        case SDL_PIXELFORMAT_BGRA5551: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
+            break;
+        }
+
+        /* packed16 formats: 565 */
+        case SDL_PIXELFORMAT_RGB565: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G6_B5;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
+            break;
+        }
+        case SDL_PIXELFORMAT_BGR565: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G6_B5;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
+            break;
+        }
+
+        /* packed32 formats */
+        case SDL_PIXELFORMAT_RGBX8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_1);
+            break;
+        }
+        case SDL_PIXELFORMAT_RGBA8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
+            break;
+        }
+        case SDL_PIXELFORMAT_ARGB8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
+            break;
+        }
+        case SDL_PIXELFORMAT_BGRX8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_1);
+            break;
+        }
+        case SDL_PIXELFORMAT_BGRA8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
+            break;
+        }
+        case SDL_PIXELFORMAT_ABGR8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_A, GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R);
+            break;
+        }
+        case SDL_PIXELFORMAT_ARGB2101010: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R10_G10_B10_A2;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
+            break;
+        }
+        default: {
+            printf("SDL: WiiU format not recognised (SDL: %08X)\n", format);
+            outFmt.fmt = -1;
+            break;
+        }
+    }
+
+    return outFmt;
+}
+
+static inline GX2BlendMode WIIU_SDL_GetBlendMode(SDL_BlendFactor factor)
+{
+    switch (factor) {
+        case SDL_BLENDFACTOR_ZERO:
+            return GX2_BLEND_MODE_ZERO;
+        case SDL_BLENDFACTOR_ONE:
+            return GX2_BLEND_MODE_ONE;
+        case SDL_BLENDFACTOR_SRC_COLOR:
+            return GX2_BLEND_MODE_SRC_COLOR;
+        case SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR:
+            return GX2_BLEND_MODE_INV_SRC_COLOR;
+        case SDL_BLENDFACTOR_SRC_ALPHA:
+            return GX2_BLEND_MODE_SRC_ALPHA;
+        case SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:
+            return GX2_BLEND_MODE_INV_SRC_ALPHA;
+        case SDL_BLENDFACTOR_DST_COLOR:
+            return GX2_BLEND_MODE_DST_COLOR;
+        case SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR:
+            return GX2_BLEND_MODE_INV_DST_COLOR;
+        case SDL_BLENDFACTOR_DST_ALPHA:
+            return GX2_BLEND_MODE_DST_ALPHA;
+        case SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA:
+            return GX2_BLEND_MODE_INV_DST_ALPHA;
+        default:
+            return -1;
+    }
+}
+
+static inline GX2BlendCombineMode WIIU_SDL_GetBlendCombineMode(SDL_BlendOperation operation)
+{
+    switch (operation) {
+        case SDL_BLENDOPERATION_ADD:
+            return GX2_BLEND_COMBINE_MODE_ADD;
+        case SDL_BLENDOPERATION_SUBTRACT:
+            return GX2_BLEND_COMBINE_MODE_SUB;
+        case SDL_BLENDOPERATION_REV_SUBTRACT:
+            return GX2_BLEND_COMBINE_MODE_REV_SUB;
+        case SDL_BLENDOPERATION_MINIMUM:
+            return GX2_BLEND_COMBINE_MODE_MIN;
+        case SDL_BLENDOPERATION_MAXIMUM:
+            return GX2_BLEND_COMBINE_MODE_MAX;
+        default:
+            return -1;
+    }
+}
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
+
+#endif /* SDL_render_wiiu_h */
diff --git a/src/render/wiiu/SDL_rpresent_wiiu.c b/src/render/wiiu/SDL_rpresent_wiiu.c
new file mode 100644
index 000000000..c0ac7a1cc
--- /dev/null
+++ b/src/render/wiiu/SDL_rpresent_wiiu.c
@@ -0,0 +1,86 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/registers.h>
+#include <gx2/state.h>
+#include <gx2/draw.h>
+#include <gx2/swap.h>
+#include <gx2/display.h>
+#include <gx2r/draw.h>
+
+static SDL_bool tvDrcEnabled = SDL_FALSE;
+
+int WIIU_SDL_SetVSync(SDL_Renderer * renderer, const int vsync)
+{
+    GX2SetSwapInterval(vsync ? 1 : 0);
+
+    if (GX2GetSwapInterval() > 0) {
+        renderer->info.flags |= SDL_RENDERER_PRESENTVSYNC;
+    } else {
+        renderer->info.flags &= ~SDL_RENDERER_PRESENTVSYNC;
+    }
+    return 0;
+}
+
+int WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) data->windowTex.driverdata;
+    Uint32 flags = SDL_GetWindowFlags(renderer->window);
+
+    /* Only render to TV if the window is *not* drc-only */
+    if (!(flags & SDL_WINDOW_WIIU_GAMEPAD_ONLY)) {
+        GX2CopyColorBufferToScanBuffer(&tdata->cbuf, GX2_SCAN_TARGET_TV);
+    }
+
+    if (!(flags & SDL_WINDOW_WIIU_TV_ONLY)) {
+        GX2CopyColorBufferToScanBuffer(&tdata->cbuf, GX2_SCAN_TARGET_DRC);
+    }
+
+    /* Swap buffers */
+    GX2SwapScanBuffers();
+    GX2Flush();
+
+    /* Restore SDL context state */
+    GX2SetContextState(data->ctx);
+
+    /* Notify renderer that the frame is complete */
+    WIIU_FrameDone(data);
+
+    /* TV and DRC can now be enabled after the first frame was drawn */
+    if (!tvDrcEnabled) {
+        GX2SetTVEnable(TRUE);
+        GX2SetDRCEnable(TRUE);
+        tvDrcEnabled = SDL_TRUE;
+    }
+
+    return 0;
+}
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
new file mode 100644
index 000000000..203648dc0
--- /dev/null
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -0,0 +1,476 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_hints.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/texture.h>
+#include <gx2/draw.h>
+#include <gx2/registers.h>
+#include <gx2/sampler.h>
+#include <gx2/state.h>
+#include <gx2/clear.h>
+#include <gx2/mem.h>
+#include <gx2/event.h>
+#include <gx2r/surface.h>
+#include <gx2r/buffer.h>
+#include <gx2r/draw.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+int WIIU_SDL_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand * cmd)
+{
+    return 0;
+}
+
+int WIIU_SDL_QueueSetDrawColor(SDL_Renderer * renderer, SDL_RenderCommand * cmd)
+{
+    return 0;
+}
+
+int WIIU_SDL_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    SDL_VertexSolid *vertices;
+    GX2RBuffer *vertexBuffer;
+    SDL_Color color;
+    color.r = cmd->data.draw.r;
+    color.g = cmd->data.draw.g;
+    color.b = cmd->data.draw.b;
+    color.a = cmd->data.draw.a;
+
+    vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(SDL_VertexSolid),
+        .elemCount = count,
+    });
+
+    if (!vertexBuffer) {
+        return -1;
+    }
+
+    cmd->data.draw.first = (size_t)vertexBuffer;
+    cmd->data.draw.count = count;
+
+    vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+    for (int i = 0; i < count; ++i) {
+        vertices[i].position.x = points[i].x;
+        vertices[i].position.y = points[i].y;
+        vertices[i].color = color;
+    }
+
+    GX2RUnlockBufferEx(vertexBuffer, 0);
+
+    return 0;
+}
+
+int WIIU_SDL_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    SDL_VertexSolid *vertices;
+    GX2RBuffer *vertexBuffer;
+    SDL_Color color;
+    color.r = cmd->data.draw.r;
+    color.g = cmd->data.draw.g;
+    color.b = cmd->data.draw.b;
+    color.a = cmd->data.draw.a;
+
+    vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(SDL_VertexSolid),
+        .elemCount = (count - 1) * 2,
+    });
+
+    if (!vertexBuffer) {
+        return -1;
+    }
+
+    cmd->data.draw.first = (size_t)vertexBuffer;
+    cmd->data.draw.count = (count - 1) * 2;
+
+    vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+    for (int i = 0; i < count - 1; ++i) {
+        vertices[i * 2].position.x = points[i].x;
+        vertices[i * 2].position.y = points[i].y;
+        vertices[i * 2].color = color;
+
+        vertices[i * 2 + 1].position.x = points[i + 1].x;
+        vertices[i * 2 + 1].position.y = points[i + 1].y;
+        vertices[i * 2 + 1].color = color;
+    }
+
+    GX2RUnlockBufferEx(vertexBuffer, 0);
+
+    return 0;
+}
+
+int WIIU_SDL_QueueGeometry(SDL_Renderer * renderer, SDL_RenderCommand * cmd, SDL_Texture * texture,
+        const float * xy, int xy_stride, const SDL_Color * color, int color_stride, const float * uv, int uv_stride,
+        int num_vertices, const void * indices, int num_indices, int size_indices,
+        float scale_x, float scale_y)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    GX2RBuffer *vertexBuffer;
+
+    int count = indices ? num_indices : num_vertices;
+    // discard empty draws or GX2 will crash
+    if (count < 1) {
+        return -1;
+    }
+
+    cmd->data.draw.count = count;
+
+    size_indices = indices ? size_indices : 0;
+
+    if (texture) {
+        SDL_Vertex *vertices;
+        vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+            .flags =
+                GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+                GX2R_RESOURCE_USAGE_CPU_WRITE,
+            .elemSize = sizeof(SDL_Vertex),
+            .elemCount = count,
+        });
+
+        if (!vertexBuffer) {
+            return -1;
+        }
+
+        vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+        for (int i = 0; i < count; i++) {
+            int j;
+            float *xy_;
+            float *uv_;
+            SDL_Color col_;
+            if (size_indices == 4) {
+                j = ((const Uint32 *)indices)[i];
+            } else if (size_indices == 2) {
+                j = ((const Uint16 *)indices)[i];
+            } else if (size_indices == 1) {
+                j = ((const Uint8 *)indices)[i];
+            } else {
+                j = i;
+            }
+
+            xy_ = (float *)((char*)xy + j * xy_stride);
+            col_ = *(SDL_Color *)((char*)color + j * color_stride);
+            uv_ = (float *)((char*)uv + j * uv_stride);
+
+            vertices[i].position.x = xy_[0] * scale_x;
+            vertices[i].position.y = xy_[1] * scale_y;
+            vertices[i].tex_coord.x = uv_[0];
+            vertices[i].tex_coord.y = uv_[1];
+            vertices[i].color = col_;
+        }
+
+        GX2RUnlockBufferEx(vertexBuffer, 0);
+
+        cmd->data.draw.first = (size_t)vertexBuffer;
+    } else {
+        SDL_VertexSolid *vertices;
+        vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+            .flags =
+                GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+                GX2R_RESOURCE_USAGE_CPU_WRITE,
+            .elemSize = sizeof(SDL_VertexSolid),
+            .elemCount = count,
+        });
+
+        if (!vertexBuffer) {
+            return -1;
+        }
+
+        vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+        for (int i = 0; i < count; i++) {
+            int j;
+            float *xy_;
+            SDL_Color col_;
+            if (size_indices == 4) {
+                j = ((const Uint32 *)indices)[i];
+            } else if (size_indices == 2) {
+                j = ((const Uint16 *)indices)[i];
+            } else if (size_indices == 1) {
+                j = ((const Uint8 *)indices)[i];
+            } else {
+                j = i;
+            }
+
+            xy_ = (float *)((char*)xy + j * xy_stride);
+            col_ = *(SDL_Color *)((char*)color + j * color_stride);
+
+            vertices[i].position.x = xy_[0] * scale_x;
+            vertices[i].position.y = xy_[1] * scale_y;
+            vertices[i].color = col_;
+        }
+
+        GX2RUnlockBufferEx(vertexBuffer, 0);
+
+        cmd->data.draw.first = (size_t)vertexBuffer;
+    }
+
+    return 0;
+}
+
+static int WIIU_SDL_RenderClear(SDL_Renderer * renderer, SDL_RenderCommand * cmd)
+{
+    WIIU_RenderData *data = (WIIU_RenderData*) renderer->driverdata;
+    SDL_Texture *target = WIIU_GetRenderTarget(renderer);
+    WIIU_TextureData *tdata = (WIIU_TextureData*) target->driverdata;
+
+    GX2ClearColor(&tdata->cbuf,
+                  (float) cmd->data.color.r / 255.0f,
+                  (float) cmd->data.color.g / 255.0f,
+                  (float) cmd->data.color.b / 255.0f,
+                  (float) cmd->data.color.a / 255.0f);
+
+    /* Restore SDL context state */
+    GX2SetContextState(data->ctx);
+
+    return 0;
+}
+
+static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand * cmd)
+{
+    SDL_bool matrixUpdated = SDL_FALSE;
+    SDL_bool shaderUpdated = SDL_FALSE;
+    const SDL_BlendMode blendMode = cmd->data.draw.blend;
+    WIIU_ShaderType shader = cmd->data.draw.texture ? SHADER_TEXTURE : SHADER_COLOR;
+    WiiU_ShaderGroup* shaderGroup = WIIU_SDL_GetShaderGroup(shader);
+    SDL_Texture *texture = cmd->data.draw.texture;
+
+    if (data->drawState.viewportDirty) {
+        const SDL_Rect *viewport = &data->drawState.viewport;
+
+        GX2SetViewport(viewport->x, viewport->y, viewport->w, viewport->h, 0.0f, 1.0f);
+
+        if (viewport->w && viewport->h) {
+            data->drawState.projectionMatrix[0][0] = 2.0f / viewport->w;
+            data->drawState.projectionMatrix[1][1] = -2.0f / viewport->h;
+            matrixUpdated = SDL_TRUE;
+        }
+
+        data->drawState.viewportDirty = SDL_FALSE;
+    }
+
+    if (data->drawState.cliprectDirty) {
+        SDL_Rect scissor;
+        const SDL_Rect *viewport = &data->drawState.viewport;
+        const SDL_Rect *rect = &data->drawState.cliprect;
+
+        /* Make sure scissor is never larger than the colorbuffer to prevent memory corruption.
+           In this case just clamp it to the viewport. */
+        scissor.x = SDL_clamp(viewport->x + rect->x, viewport->x, viewport->x + viewport->w);
+        scissor.y = SDL_clamp(viewport->y + rect->y, viewport->y, viewport->y + viewport->h);
+        scissor.w = SDL_clamp(rect->w, 0, (viewport->x + viewport->w) - scissor.x);
+        scissor.h = SDL_clamp(rect->h, 0, (viewport->y + viewport->h) - scissor.y);
+
+        GX2SetScissor(scissor.x, scissor.y, scissor.w, scissor.h);
+
+        data->drawState.cliprectDirty = SDL_FALSE;
+    }
+
+    if (blendMode != data->drawState.blendMode) {
+        if (blendMode == SDL_BLENDMODE_NONE) {
+            GX2SetColorControl(GX2_LOGIC_OP_COPY, 0x00, FALSE, TRUE);
+        } else {
+            GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
+            GX2SetBlendControl(GX2_RENDER_TARGET_0,
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeSrcColorFactor(blendMode)),
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeDstColorFactor(blendMode)),
+                WIIU_SDL_GetBlendCombineMode(SDL_GetBlendModeColorOperation(blendMode)),
+                TRUE,
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeSrcAlphaFactor(blendMode)),
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeDstAlphaFactor(blendMode)),
+                WIIU_SDL_GetBlendCombineMode(SDL_GetBlendModeAlphaOperation(blendMode)));
+        }
+
+        data->drawState.blendMode = blendMode;
+    }
+
+    if (shader != data->drawState.shader) {
+        WIIU_SDL_SelectShader(shader);
+        shaderUpdated = SDL_TRUE;
+        data->drawState.shader = shader;
+    }
+
+    if (shaderUpdated || matrixUpdated) {
+        GX2SetVertexUniformReg(shaderGroup->vertexShader->uniformVars[0].offset, 16, data->drawState.projectionMatrix);
+    }
+
+    if (texture != data->drawState.texture) {
+        if (texture) {
+            WIIU_TextureData *tdata = (WIIU_TextureData*) texture->driverdata;
+            uint32_t location = shaderGroup->pixelShader->samplerVars[0].location;
+            GX2SetPixelTexture(&tdata->texture, location);
+            GX2SetPixelSampler(&tdata->sampler, location);
+        }
+
+        data->drawState.texture = texture;
+    }
+
+    if (texture) {
+        WIIU_TextureData *tdata = (WIIU_TextureData*) texture->driverdata;
+        WIIU_TextureMarkUsed(data, tdata);
+    }
+
+    return 0;
+}
+
+int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)
+{
+    WIIU_RenderData* data = (WIIU_RenderData*) renderer->driverdata;
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
+
+    /* The command queue is still ran, even with DONT_DRAW_WHILE_HIDDEN
+       So check manually for foreground here */
+    if (!videodata->hasForeground) {
+        return 0;
+    }
+
+    /* make sure we're using the correct renderer ctx */
+    WIIU_SDL_SetRenderTarget(renderer, renderer->target);
+
+    data->drawState.target = renderer->target;
+    if (!data->drawState.target) {
+        int w, h;
+        SDL_GL_GetDrawableSize(renderer->window, &w, &h);
+        if ((w != data->drawState.drawableWidth) || (h != data->drawState.drawableHeight)) {
+            /* if the window dimensions changed, invalidate the current viewport, etc. */
+            data->drawState.viewportDirty = SDL_TRUE;
+            data->drawState.cliprectDirty = SDL_TRUE;
+            data->drawState.drawableWidth = w;
+            data->drawState.drawableHeight = h;
+        }
+    }
+
+    while (cmd) {
+        switch (cmd->command) {
+
+            case SDL_RENDERCMD_SETVIEWPORT: {
+                SDL_Rect *viewport = &data->drawState.viewport;
+                if (SDL_memcmp(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect));
+                    data->drawState.viewportDirty = SDL_TRUE;
+
+                    if (!data->drawState.cliprectEnabled) {
+                        /* If the clip rect is disabled, then the scissor rect should be the whole viewport */
+                        data->drawState.cliprect.x = 0;
+                        data->drawState.cliprect.y = 0;
+                        data->drawState.cliprect.w = viewport->w;
+                        data->drawState.cliprect.h = viewport->h;
+                        data->drawState.cliprectDirty = SDL_TRUE;
+                    }
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_SETCLIPRECT: {
+                SDL_Rect noclip;
+                const SDL_Rect *viewport = &data->drawState.viewport;
+                const SDL_Rect *rect = &cmd->data.cliprect.rect;
+                if (data->drawState.cliprectEnabled != cmd->data.cliprect.enabled) {
+                    data->drawState.cliprectEnabled = cmd->data.cliprect.enabled;
+                    data->drawState.cliprectDirty = SDL_TRUE;
+                }
+
+                if (!data->drawState.cliprectEnabled) {
+                    /* If the clip rect is disabled, then the scissor rect should be the whole viewport */
+                    noclip.x = 0;
+                    noclip.y = 0;
+                    noclip.w = viewport->w;
+                    noclip.h = viewport->h;
+                    rect = &noclip;
+                }
+
+                if (SDL_memcmp(&data->drawState.cliprect, rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(&data->drawState.cliprect, rect, sizeof (SDL_Rect));
+                    data->drawState.cliprectDirty = SDL_TRUE;
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_SETDRAWCOLOR:
+                break;
+
+            case SDL_RENDERCMD_CLEAR: {
+                WIIU_SDL_RenderClear(renderer, cmd);
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_POINTS: {
+                GX2RBuffer *vertexBuffer = (GX2RBuffer *) cmd->data.draw.first;
+                if (WIIU_SDL_SetDrawState(data, cmd) == 0) {
+                    GX2RSetAttributeBuffer(vertexBuffer, 0, vertexBuffer->elemSize, 0);
+                    GX2DrawEx(GX2_PRIMITIVE_MODE_POINTS, cmd->data.draw.count, 0, 1);
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_LINES: {
+                GX2RBuffer *vertexBuffer = (GX2RBuffer *) cmd->data.draw.first;
+                if (WIIU_SDL_SetDrawState(data, cmd) == 0) {
+                    GX2RSetAttributeBuffer(vertexBuffer, 0, vertexBuffer->elemSize, 0);
+                    GX2DrawEx(GX2_PRIMITIVE_MODE_LINE_STRIP, cmd->data.draw.count, 0, 1);
+                }
+                break;
+            }
+
+            /* unused (will be handled by geometry) */
+            case SDL_RENDERCMD_FILL_RECTS:
+            case SDL_RENDERCMD_COPY:
+            case SDL_RENDERCMD_COPY_EX:
+                break;
+
+            case SDL_RENDERCMD_GEOMETRY: {
+                GX2RBuffer *vertexBuffer = (GX2RBuffer *) cmd->data.draw.first;
+                if (WIIU_SDL_SetDrawState(data, cmd) == 0) {
+                    GX2RSetAttributeBuffer(vertexBuffer, 0, vertexBuffer->elemSize, 0);
+                    GX2DrawEx(GX2_PRIMITIVE_MODE_TRIANGLES, cmd->data.draw.count, 0, 1);
+                }
+            }
+
+            case SDL_RENDERCMD_NO_OP:
+                break;
+        }
+
+        cmd = cmd->next;
+    }
+
+    return 0;
+}
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_rtexture_wiiu.c b/src/render/wiiu/SDL_rtexture_wiiu.c
new file mode 100644
index 000000000..1bb475543
--- /dev/null
+++ b/src/render/wiiu/SDL_rtexture_wiiu.c
@@ -0,0 +1,232 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/context.h>
+#include <gx2/texture.h>
+#include <gx2/sampler.h>
+#include <gx2/mem.h>
+#include <gx2r/surface.h>
+#include <gx2r/resource.h>
+
+#include <malloc.h>
+#include <stdarg.h>
+
+int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    BOOL res;
+    WIIU_PixFmt gx2_fmt;
+    GX2RResourceFlags surface_flags;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) SDL_calloc(1, sizeof(*tdata));
+    if (!tdata) {
+        return SDL_OutOfMemory();
+    }
+
+    /* Setup sampler */
+    if (texture->scaleMode == SDL_ScaleModeNearest) {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_POINT);
+    } else {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_LINEAR);
+    }
+
+    gx2_fmt = WIIU_SDL_GetPixFmt(texture->format);
+    if (gx2_fmt.fmt == -1) {
+        return SDL_SetError("Unsupported texture format");
+    }
+
+    /* Setup GX2Texture */
+    tdata->texture.surface.width = texture->w;
+    tdata->texture.surface.height = texture->h;
+    tdata->texture.surface.format = gx2_fmt.fmt;
+    tdata->texture.surface.depth = 1;
+    tdata->texture.surface.dim = GX2_SURFACE_DIM_TEXTURE_2D;
+    tdata->texture.surface.tileMode = GX2_TILE_MODE_LINEAR_ALIGNED;
+    tdata->texture.surface.mipLevels = 1;
+    tdata->texture.viewNumMips = 1;
+    tdata->texture.viewNumSlices = 1;
+    tdata->texture.compMap = gx2_fmt.compMap;
+    GX2CalcSurfaceSizeAndAlignment(&tdata->texture.surface);
+    GX2InitTextureRegs(&tdata->texture);
+
+    /* Setup GX2ColorBuffer */
+    tdata->cbuf.surface = tdata->texture.surface;
+    tdata->cbuf.viewNumSlices = 1;
+    GX2InitColorBufferRegs(&tdata->cbuf);
+
+    /* Texture's surface flags */
+    surface_flags = GX2R_RESOURCE_BIND_TEXTURE | GX2R_RESOURCE_BIND_COLOR_BUFFER |
+                    GX2R_RESOURCE_USAGE_CPU_WRITE | GX2R_RESOURCE_USAGE_CPU_READ |
+                    GX2R_RESOURCE_USAGE_GPU_WRITE | GX2R_RESOURCE_USAGE_GPU_READ;
+
+    /* Allocate normal textures from MEM2 */
+    if (texture->driverdata != WIIU_TEXTURE_MEM1_MAGIC)
+        surface_flags |= GX2R_RESOURCE_USAGE_FORCE_MEM2;
+
+    /* Allocate the texture's surface */
+    res = GX2RCreateSurface(
+        &tdata->texture.surface,
+        surface_flags
+    );
+    if (!res) {
+        SDL_free(tdata);
+        return SDL_OutOfMemory();
+    }
+
+    /* Allocate a colour buffer, using the same backing buffer */
+    res = GX2RCreateSurfaceUserMemory(
+        &tdata->cbuf.surface,
+        tdata->texture.surface.image,
+        tdata->texture.surface.mipmaps,
+        tdata->texture.surface.resourceFlags
+    );
+    if (!res) {
+        GX2RDestroySurfaceEx(&tdata->texture.surface, 0);
+        SDL_free(tdata);
+        return SDL_OutOfMemory();
+    }
+
+    /* Setup texture driver data */
+    texture->driverdata = tdata;
+
+    return 0;
+}
+
+/* Somewhat adapted from SDL_render.c: SDL_LockTextureNative
+   The app basically wants a pointer to a particular rectangle as well as
+   write access to it. Easy GX2R! */
+int WIIU_SDL_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                         const SDL_Rect * rect, void **pixels, int *pitch)
+{
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+    Uint32 BytesPerPixel = SDL_BYTESPERPIXEL(texture->format);
+    void* pixel_buffer;
+
+    if (videodata->hasForeground && WIIU_TextureInUse(data, tdata)) {
+        /* Wait for the texture rendering to finish */
+        WIIU_TextureWaitDone(data, tdata);
+    }
+
+    pixel_buffer = GX2RLockSurfaceEx(&tdata->texture.surface, 0, 0);
+
+    /* Calculate pointer to first pixel in rect */
+    *pixels = (void *) ((Uint8 *) pixel_buffer +
+                        rect->y * (tdata->texture.surface.pitch * BytesPerPixel) +
+                        rect->x * BytesPerPixel);
+    *pitch = (tdata->texture.surface.pitch * BytesPerPixel);
+
+    /* Not sure we even need to bother keeping track of this */
+    texture->locked_rect = *rect;
+
+    return 0;
+}
+
+void WIIU_SDL_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+    GX2RUnlockSurfaceEx(&tdata->texture.surface, 0, 0);
+}
+
+void WIIU_SDL_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode)
+{
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+
+    if (texture->scaleMode == SDL_ScaleModeNearest) {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_POINT);
+    } else {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_LINEAR);
+    }
+}
+
+int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                           const SDL_Rect * rect, const void *pixels, int pitch)
+{
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
+    Uint32 BytesPerPixel = SDL_BYTESPERPIXEL(texture->format);
+    size_t length = rect->w * BytesPerPixel;
+    Uint8 *src = (Uint8 *) pixels, *dst;
+    int row, dst_pitch;
+
+    if (!videodata->hasForeground) {
+        return 0;
+    }
+
+    /* We write the rules, and we say all textures are streaming */
+    WIIU_SDL_LockTexture(renderer, texture, rect, (void**)&dst, &dst_pitch);
+
+    for (row = 0; row < rect->h; ++row) {
+        SDL_memcpy(dst, src, length);
+        src += pitch;
+        dst += dst_pitch;
+    }
+
+    WIIU_SDL_UnlockTexture(renderer, texture);
+
+    return 0;
+}
+
+void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
+    WIIU_RenderData *data;
+    WIIU_TextureData *tdata;
+
+    if (texture == NULL || texture->driverdata == NULL) {
+        return;
+    }
+
+    data = (WIIU_RenderData *) renderer->driverdata;
+    tdata = (WIIU_TextureData *) texture->driverdata;
+
+    if (videodata->hasForeground) {
+        /* Wait for the texture rendering to finish */
+        if (WIIU_TextureInUse(data, tdata)) {
+            WIIU_TextureWaitDone(data, tdata);
+        }
+
+        /* When destroying a render target wait for the GPU to catch up completely */
+        if (texture->access == SDL_TEXTUREACCESS_TARGET) {
+            GX2DrawDone();
+        }
+    }
+
+    if (data->drawState.texture == texture) {
+        data->drawState.texture = NULL;
+    }
+    if (data->drawState.target == texture) {
+        data->drawState.target = NULL;
+    }
+
+    GX2RDestroySurfaceEx(&tdata->cbuf.surface, 0);
+    GX2RDestroySurfaceEx(&tdata->texture.surface, 0);
+
+    SDL_free(tdata);
+}
+
+#endif //SDL_VIDEO_RENDER_WIIU
diff --git a/src/render/wiiu/SDL_rwindow_wiiu.c b/src/render/wiiu/SDL_rwindow_wiiu.c
new file mode 100644
index 000000000..0403e68de
--- /dev/null
+++ b/src/render/wiiu/SDL_rwindow_wiiu.c
@@ -0,0 +1,38 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_render_wiiu.h"
+
+void WIIU_SDL_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)
+{
+    if (event->event == SDL_WINDOWEVENT_SIZE_CHANGED) {
+        /* Re-init the colour buffer etc. for new window size */
+        WIIU_SDL_CreateWindowTex(renderer, renderer->window);
+        WIIU_SDL_SetRenderTarget(renderer, NULL);
+    }
+}
+
+#endif //SDL_VIDEO_RENDER_WIIU
diff --git a/src/render/wiiu/SDL_shaders_wiiu.c b/src/render/wiiu/SDL_shaders_wiiu.c
new file mode 100644
index 000000000..03a35c769
--- /dev/null
+++ b/src/render/wiiu/SDL_shaders_wiiu.c
@@ -0,0 +1,257 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "SDL_shaders_wiiu.h"
+#include "SDL_render.h"
+#include "../SDL_sysrender.h"
+
+#include <malloc.h>
+#include <gfd.h>
+#include <gx2/utils.h>
+#include <gx2/mem.h>
+
+#include "shaders/colorShader.inc"
+#include "shaders/textureShader.inc"
+
+static WiiU_ShaderGroup shaderGroups[NUM_SHADERS];
+static int shaderRefCount = 0;
+
+static GX2VertexShader* WiiU_LoadGFDVertexShader(uint32_t index, const void* file)
+{
+    uint32_t headerSize, programSize;
+    GX2VertexShader* shader = NULL;
+    void* program = NULL;
+
+    if (index >= GFDGetVertexShaderCount(file)) {
+        return NULL;
+    }
+
+    if ((headerSize = GFDGetVertexShaderHeaderSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if ((programSize = GFDGetVertexShaderProgramSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if (!(shader = memalign(0x40, headerSize))) {
+        return NULL;
+    }
+
+    shader->gx2rBuffer.flags = GX2R_RESOURCE_BIND_SHADER_PROGRAM |
+                               GX2R_RESOURCE_USAGE_CPU_READ |
+                               GX2R_RESOURCE_USAGE_CPU_WRITE |
+                               GX2R_RESOURCE_USAGE_GPU_READ;
+    shader->gx2rBuffer.elemSize = programSize;
+    shader->gx2rBuffer.elemCount = 1;
+    shader->gx2rBuffer.buffer = NULL;
+    if (!GX2RCreateBuffer(&shader->gx2rBuffer)) {
+        free(shader);
+        return NULL;
+    }
+
+    program = GX2RLockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    if (!GFDGetVertexShader(shader, program, index, file)) {
+        GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_DISABLE_CPU_INVALIDATE |
+                                                GX2R_RESOURCE_DISABLE_GPU_INVALIDATE);
+        GX2RDestroyBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+        free(shader);
+        return NULL;
+    }
+
+    GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    // according to wut this needs to be invalidated again for some reason
+    GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, shader->program, shader->size);
+    return shader;
+}
+
+static GX2PixelShader* WiiU_LoadGFDPixelShader(uint32_t index, const void* file)
+{
+    uint32_t headerSize, programSize;
+    GX2PixelShader* shader = NULL;
+    void* program = NULL;
+
+    if (index >= GFDGetPixelShaderCount(file)) {
+        return NULL;
+    }
+
+    if ((headerSize = GFDGetPixelShaderHeaderSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if ((programSize = GFDGetPixelShaderProgramSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if (!(shader = memalign(0x40, headerSize))) {
+        return NULL;
+    }
+
+    shader->gx2rBuffer.flags = GX2R_RESOURCE_BIND_SHADER_PROGRAM |
+                               GX2R_RESOURCE_USAGE_CPU_READ |
+                               GX2R_RESOURCE_USAGE_CPU_WRITE |
+                               GX2R_RESOURCE_USAGE_GPU_READ;
+    shader->gx2rBuffer.elemSize = programSize;
+    shader->gx2rBuffer.elemCount = 1;
+    shader->gx2rBuffer.buffer = NULL;
+    if (!GX2RCreateBuffer(&shader->gx2rBuffer)) {
+        free(shader);
+        return NULL;
+    }
+
+    program = GX2RLockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    if (!GFDGetPixelShader(shader, program, index, file)) {
+        GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_DISABLE_CPU_INVALIDATE |
+                                                GX2R_RESOURCE_DISABLE_GPU_INVALIDATE);
+        GX2RDestroyBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+        free(shader);
+        return NULL;
+    }
+
+    GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    // according to wut this needs to be invalidated again for some reason
+    GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, shader->program, shader->size);
+    return shader;
+}
+
+static int WiiU_LoadGFDShaderGroup(WiiU_ShaderGroup* group, uint32_t index, const void* file)
+{
+    group->vertexShader = WiiU_LoadGFDVertexShader(index, file);
+    if (!group->vertexShader) {
+        return -1;
+    }
+
+    group->pixelShader = WiiU_LoadGFDPixelShader(index, file);
+    if (!group->pixelShader) {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int WiiU_CreateFetchShader(WiiU_ShaderGroup* group, GX2AttribStream* attributes, uint32_t numAttributes)
+{
+    uint32_t size = GX2CalcFetchShaderSizeEx(numAttributes, GX2_FETCH_SHADER_TESSELLATION_NONE, GX2_TESSELLATION_MODE_DISCRETE);
+    if (!size) {
+        return -1;
+    }
+
+    group->fetchShaderProgram = memalign(GX2_SHADER_PROGRAM_ALIGNMENT, size);
+    if (!group->fetchShaderProgram) {
+        return -1;
+    }
+
+    GX2InitFetchShaderEx(&group->fetchShader,
+                         group->fetchShaderProgram,
+                         numAttributes,
+                         attributes,
+                         GX2_FETCH_SHADER_TESSELLATION_NONE,
+                         GX2_TESSELLATION_MODE_DISCRETE);
+
+    GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, group->fetchShaderProgram, size);
+    return 0;
+}
+
+static void WiiU_FreeShaderGroup(WiiU_ShaderGroup* group)
+{
+    GX2RDestroyBufferEx(&group->vertexShader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    free(group->vertexShader);
+
+    GX2RDestroyBufferEx(&group->pixelShader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    free(group->pixelShader);
+
+    free(group->fetchShaderProgram);
+}
+
+void WIIU_SDL_CreateShaders(void)
+{
+    if (!shaderRefCount++) {
+        GX2AttribStream attributes[3];
+
+        // a_position
+        attributes[0] = (GX2AttribStream) { 
+            0, 0, offsetof(SDL_VertexSolid, position),
+            GX2_ATTRIB_FORMAT_FLOAT_32_32, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_0, GX2_SQ_SEL_1),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        // a_color
+        attributes[1] = (GX2AttribStream) { 
+            1, 0, offsetof(SDL_VertexSolid, color),
+            GX2_ATTRIB_FORMAT_UNORM_8_8_8_8, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_Z, GX2_SQ_SEL_W),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        WiiU_LoadGFDShaderGroup(&shaderGroups[SHADER_COLOR], 0, colorShader_gsh);
+        WiiU_CreateFetchShader(&shaderGroups[SHADER_COLOR], attributes, 2);
+
+        // a_position
+        attributes[0] = (GX2AttribStream) { 
+            0, 0, offsetof(SDL_Vertex, position),
+            GX2_ATTRIB_FORMAT_FLOAT_32_32, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_0, GX2_SQ_SEL_1),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        // a_color
+        attributes[1] = (GX2AttribStream) { 
+            1, 0, offsetof(SDL_Vertex, color),
+            GX2_ATTRIB_FORMAT_UNORM_8_8_8_8, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_Z, GX2_SQ_SEL_W),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        // a_texcoord
+        attributes[2] = (GX2AttribStream) { 
+            2, 0, offsetof(SDL_Vertex, tex_coord),
+            GX2_ATTRIB_FORMAT_FLOAT_32_32, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_0, GX2_SQ_SEL_1),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        WiiU_LoadGFDShaderGroup(&shaderGroups[SHADER_TEXTURE], 0, textureShader_gsh);
+        WiiU_CreateFetchShader(&shaderGroups[SHADER_TEXTURE], attributes, 3);
+    }
+}
+
+void WIIU_SDL_DestroyShaders(void)
+{
+    if (!--shaderRefCount) {
+        WiiU_FreeShaderGroup(&shaderGroups[SHADER_COLOR]);
+        WiiU_FreeShaderGroup(&shaderGroups[SHADER_TEXTURE]);
+    }
+}
+
+void WIIU_SDL_SelectShader(WIIU_ShaderType shader)
+{
+    WiiU_ShaderGroup* shaderGroup = &shaderGroups[shader];
+
+    GX2SetFetchShader(&shaderGroup->fetchShader);
+    GX2SetVertexShader(shaderGroup->vertexShader);
+    GX2SetPixelShader(shaderGroup->pixelShader);
+}
+
+WiiU_ShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader)
+{
+    return &shaderGroups[shader];
+}
+
+#endif //SDL_VIDEO_RENDER_WIIU
diff --git a/src/render/wiiu/SDL_shaders_wiiu.h b/src/render/wiiu/SDL_shaders_wiiu.h
new file mode 100644
index 000000000..fbb7903af
--- /dev/null
+++ b/src/render/wiiu/SDL_shaders_wiiu.h
@@ -0,0 +1,51 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_shaders_wiiu_h
+#define SDL_shaders_wiiu_h
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include <gx2/shaders.h>
+
+typedef enum {
+    SHADER_INVALID = -1,
+    SHADER_COLOR,
+    SHADER_TEXTURE,
+    NUM_SHADERS
+} WIIU_ShaderType;
+
+typedef struct {
+   GX2FetchShader fetchShader;
+   void* fetchShaderProgram;
+   GX2VertexShader* vertexShader;
+   GX2PixelShader* pixelShader;
+} WiiU_ShaderGroup;
+
+void WIIU_SDL_CreateShaders(void);
+void WIIU_SDL_DestroyShaders(void);
+void WIIU_SDL_SelectShader(WIIU_ShaderType shader);
+WiiU_ShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader);
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
+
+#endif /* SDL_shaders_wiiu_h */
diff --git a/src/render/wiiu/shaders/.gitignore b/src/render/wiiu/shaders/.gitignore
new file mode 100644
index 000000000..3fd11a5ac
--- /dev/null
+++ b/src/render/wiiu/shaders/.gitignore
@@ -0,0 +1,2 @@
+latte-assembler
+*.gsh
diff --git a/src/render/wiiu/shaders/build_shaders.sh b/src/render/wiiu/shaders/build_shaders.sh
new file mode 100755
index 000000000..33b7cfc94
--- /dev/null
+++ b/src/render/wiiu/shaders/build_shaders.sh
@@ -0,0 +1,17 @@
+#!/bin/bash
+# to build shaders you need to place a copy of latte-assembler into the current directory
+# latte-assembler is part of decaf-emu <https://github.com/decaf-emu/decaf-emu>
+
+cd "${0%/*}"
+
+# colorShader
+echo "Building colorShader ..."
+./latte-assembler assemble --vsh=colorShader.vsh --psh=colorShader.psh colorShader.gsh
+xxd -i colorShader.gsh > colorShader.inc
+echo "Done!"
+
+# textureShader
+echo "Building textureShader ..."
+./latte-assembler assemble --vsh=textureShader.vsh --psh=textureShader.psh textureShader.gsh
+xxd -i textureShader.gsh > textureShader.inc
+echo "Done!"
diff --git a/src/render/wiiu/shaders/colorShader.inc b/src/render/wiiu/shaders/colorShader.inc
new file mode 100644
index 000000000..90543c0ad
--- /dev/null
+++ b/src/render/wiiu/shaders/colorShader.inc
@@ -0,0 +1,111 @@
+unsigned char colorShader_gsh[] = {
+  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xc8, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x70,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x34,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x48, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x68, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xca, 0x70, 0x01, 0x78,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x84, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0x75, 0x5f, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63,
+  0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x61, 0x5f, 0x70, 0x6f,
+  0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x61, 0x5f, 0x63, 0x6f,
+  0x6c, 0x6f, 0x72, 0x00, 0xd0, 0x60, 0x00, 0xe8, 0xd0, 0x60, 0x01, 0x08,
+  0xca, 0x70, 0x01, 0x34, 0xca, 0x70, 0x01, 0x48, 0xca, 0x70, 0x01, 0x58,
+  0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x01, 0x8c, 0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24,
+  0xd0, 0x60, 0x01, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
+  0xd0, 0x60, 0x01, 0x8c, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
+  0x00, 0x00, 0x01, 0x70, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x09, 0x20, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x34, 0xa0, 0x3c, 0xa0, 0x00, 0x00, 0x88, 0x06, 0x00, 0x94,
+  0x00, 0x40, 0x01, 0x00, 0x88, 0x06, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0xfd, 0x60, 0x20, 0x00, 0x80, 0x00, 0x00, 0x00,
+  0xfd, 0x64, 0xa0, 0x00, 0x80, 0x00, 0x00, 0x20, 0xfd, 0x68, 0x20, 0x01,
+  0x80, 0x00, 0x00, 0x40, 0xfd, 0x6c, 0xa0, 0x81, 0x80, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
+  0x00, 0x00, 0x80, 0x3f, 0x01, 0x24, 0x20, 0x00, 0xfe, 0x00, 0xe2, 0x0f,
+  0x01, 0x24, 0xa0, 0x00, 0xfe, 0x04, 0xe2, 0x2f, 0x01, 0x24, 0x20, 0x01,
+  0xfe, 0x08, 0xe2, 0x4f, 0x01, 0x24, 0xa0, 0x81, 0xfe, 0x0c, 0xe2, 0x6f,
+  0x01, 0x00, 0x20, 0x00, 0xfe, 0x00, 0x22, 0x00, 0x01, 0x00, 0xa0, 0x00,
+  0xfe, 0x04, 0x22, 0x20, 0x01, 0x00, 0x20, 0x01, 0xfe, 0x08, 0x22, 0x40,
+  0x01, 0x00, 0xa0, 0x81, 0xfe, 0x0c, 0x22, 0x60, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
+  0x14, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x42, 0x4c, 0x4b,
+  0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8,
+  0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8,
+  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x88, 0x06, 0x20, 0x94, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
+};
+unsigned int colorShader_gsh_len = 1296;
diff --git a/src/render/wiiu/shaders/colorShader.psh b/src/render/wiiu/shaders/colorShader.psh
new file mode 100644
index 000000000..bd3d9e700
--- /dev/null
+++ b/src/render/wiiu/shaders/colorShader.psh
@@ -0,0 +1,9 @@
+; $MODE = "UniformRegister"
+
+; $NUM_SPI_PS_INPUT_CNTL = 1
+; v_color R0
+; $SPI_PS_INPUT_CNTL[0].SEMANTIC = 0
+; $SPI_PS_INPUT_CNTL[0].DEFAULT_VAL = 1
+
+00 EXP_DONE: PIX0, R0
+END_OF_PROGRAM
diff --git a/src/render/wiiu/shaders/colorShader.vsh b/src/render/wiiu/shaders/colorShader.vsh
new file mode 100644
index 000000000..ee69cbd3a
--- /dev/null
+++ b/src/render/wiiu/shaders/colorShader.vsh
@@ -0,0 +1,40 @@
+; $MODE = "UniformRegister"
+
+; $SPI_VS_OUT_CONFIG.VS_EXPORT_COUNT = 0
+; $NUM_SPI_VS_OUT_ID = 1
+; v_color
+; $SPI_VS_OUT_ID[0].SEMANTIC_0 = 0
+
+; C0
+; $UNIFORM_VARS[0].name = "u_projection"
+; $UNIFORM_VARS[0].type = "mat4"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].block = -1
+; $UNIFORM_VARS[0].offset = 0
+
+; R1
+; $ATTRIB_VARS[0].name = "a_position"
+; $ATTRIB_VARS[0].type = "vec2"
+; $ATTRIB_VARS[0].location = 0
+; R2
+; $ATTRIB_VARS[1].name = "a_color"
+; $ATTRIB_VARS[1].type = "vec4"
+; $ATTRIB_VARS[1].location = 1
+
+00 CALL_FS NO_BARRIER
+01 ALU: ADDR(32) CNT(14)
+    0  x: MUL    ____,   1.0f, C3.x
+       y: MUL    ____,   1.0f, C3.y
+       z: MUL    ____,   1.0f, C3.z
+       w: MUL    ____,   1.0f, C3.w
+    1  x: MULADD R127.x, R1.y, C1.x, PV0.x
+       y: MULADD R127.y, R1.y, C1.y, PV0.y
+       z: MULADD R127.z, R1.y, C1.z, PV0.z
+       w: MULADD R127.w, R1.y, C1.w, PV0.w
+    2  x: MULADD R1.x,   R1.x, C0.x, PV0.x
+       y: MULADD R1.y,   R1.x, C0.y, PV0.y
+       z: MULADD R1.z,   R1.x, C0.z, PV0.z
+       w: MULADD R1.w,   R1.x, C0.w, PV0.w
+02 EXP_DONE: POS0, R1
+03 EXP_DONE: PARAM0, R2 NO_BARRIER
+END_OF_PROGRAM
diff --git a/src/render/wiiu/shaders/textureShader.inc b/src/render/wiiu/shaders/textureShader.inc
new file mode 100644
index 000000000..a47c11136
--- /dev/null
+++ b/src/render/wiiu/shaders/textureShader.inc
@@ -0,0 +1,149 @@
+unsigned char textureShader_gsh[] = {
+  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xe8, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x01, 0x00,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x70,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x34,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0xd0, 0x60, 0x01, 0x48, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x78, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xca, 0x70, 0x01, 0x88,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x94, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0xca, 0x70, 0x01, 0x9c, 0x00, 0x00, 0x00, 0x09,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x75, 0x5f, 0x70, 0x72,
+  0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00,
+  0x61, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,
+  0x61, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x61, 0x5f, 0x74, 0x65,
+  0x78, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8,
+  0xd0, 0x60, 0x01, 0x08, 0xca, 0x70, 0x01, 0x34, 0xca, 0x70, 0x01, 0x48,
+  0xca, 0x70, 0x01, 0x58, 0xca, 0x70, 0x01, 0x68, 0x7d, 0x42, 0x4c, 0x4b,
+  0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa8,
+  0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xd0, 0x60, 0x01, 0x78,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xd0, 0x60, 0x01, 0xa8,
+  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x70,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x80, 0x09, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xa0,
+  0x3c, 0xa0, 0x00, 0x00, 0x88, 0x06, 0x00, 0x94, 0x00, 0x40, 0x01, 0x00,
+  0x88, 0x06, 0x80, 0x13, 0x01, 0xc0, 0x01, 0x00, 0x08, 0x09, 0x20, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xfd, 0x60, 0x20, 0x00, 0x80, 0x00, 0x00, 0x00, 0xfd, 0x64, 0xa0, 0x00,
+  0x80, 0x00, 0x00, 0x20, 0xfd, 0x68, 0x20, 0x01, 0x80, 0x00, 0x00, 0x40,
+  0xfd, 0x6c, 0xa0, 0x81, 0x80, 0x00, 0x00, 0x60, 0x00, 0x00, 0x80, 0x3f,
+  0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
+  0x01, 0x24, 0x20, 0x00, 0xfe, 0x00, 0xe2, 0x0f, 0x01, 0x24, 0xa0, 0x00,
+  0xfe, 0x04, 0xe2, 0x2f, 0x01, 0x24, 0x20, 0x01, 0xfe, 0x08, 0xe2, 0x4f,
+  0x01, 0x24, 0xa0, 0x81, 0xfe, 0x0c, 0xe2, 0x6f, 0x01, 0x00, 0x20, 0x00,
+  0xfe, 0x00, 0x22, 0x00, 0x01, 0x00, 0xa0, 0x00, 0xfe, 0x04, 0x22, 0x20,
+  0x01, 0x00, 0x20, 0x01, 0xfe, 0x08, 0x22, 0x40, 0x01, 0x00, 0xa0, 0x81,
+  0xfe, 0x0c, 0x22, 0x60, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
+  0x00, 0x00, 0x01, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x14, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00,
+  0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xe8,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x00, 0xf4, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x75, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72,
+  0x65, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xd4, 0xca, 0x70, 0x00, 0xe8,
+  0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x01, 0x00, 0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
+  0xd0, 0x60, 0x00, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0xd0, 0x60, 0x01, 0x00, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x01, 0x90, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x80, 0x20, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x0c, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x20, 0x94,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
+  0x00, 0x24, 0x80, 0x00, 0x90, 0x00, 0x00, 0x20, 0x00, 0x28, 0x00, 0x01,
+  0x90, 0x00, 0x00, 0x40, 0x00, 0x2c, 0x80, 0x81, 0x90, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x10, 0x00, 0x01, 0x00, 0x01, 0x10, 0x0d, 0xf0, 0x00, 0x00, 0x80, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
+};
+unsigned int textureShader_gsh_len = 1752;
diff --git a/src/render/wiiu/shaders/textureShader.psh b/src/render/wiiu/shaders/textureShader.psh
new file mode 100644
index 000000000..18e7770f6
--- /dev/null
+++ b/src/render/wiiu/shaders/textureShader.psh
@@ -0,0 +1,23 @@
+; $MODE = "UniformRegister"
+
+; $NUM_SPI_PS_INPUT_CNTL = 2
+; v_color R0
+; $SPI_PS_INPUT_CNTL[0].SEMANTIC = 0
+; $SPI_PS_INPUT_CNTL[0].DEFAULT_VAL = 1
+; v_texCoord R1
+; $SPI_PS_INPUT_CNTL[1].SEMANTIC = 1
+; $SPI_PS_INPUT_CNTL[1].DEFAULT_VAL = 1
+
+; $SAMPLER_VARS[0].name = "u_texture"
+; $SAMPLER_VARS[0].type = "SAMPLER2D"
+; $SAMPLER_VARS[0].location = 0
+
+00 TEX: ADDR(48) CNT(1) VALID_PIX
+    0  SAMPLE R1, R1.xy0x, t0, s0
+01 ALU: ADDR(32) CNT(4)
+    1  x: MUL R0.x, R0.x, R1.x
+       y: MUL R0.y, R0.y, R1.y
+       z: MUL R0.z, R0.z, R1.z
+       w: MUL R0.w, R0.w, R1.w
+02 EXP_DONE: PIX0, R0
+END_OF_PROGRAM
diff --git a/src/render/wiiu/shaders/textureShader.vsh b/src/render/wiiu/shaders/textureShader.vsh
new file mode 100644
index 000000000..86288ff34
--- /dev/null
+++ b/src/render/wiiu/shaders/textureShader.vsh
@@ -0,0 +1,47 @@
+; $MODE = "UniformRegister"
+
+; $SPI_VS_OUT_CONFIG.VS_EXPORT_COUNT = 1
+; $NUM_SPI_VS_OUT_ID = 1
+; v_color
+; $SPI_VS_OUT_ID[0].SEMANTIC_0 = 0
+; v_texCoord
+; $SPI_VS_OUT_ID[0].SEMANTIC_1 = 1
+
+; C0
+; $UNIFORM_VARS[0].name = "u_projection"
+; $UNIFORM_VARS[0].type = "mat4"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].block = -1
+; $UNIFORM_VARS[0].offset = 0
+
+; R1
+; $ATTRIB_VARS[0].name = "a_position"
+; $ATTRIB_VARS[0].type = "vec2"
+; $ATTRIB_VARS[0].location = 0
+; R2
+; $ATTRIB_VARS[1].name = "a_color"
+; $ATTRIB_VARS[1].type = "vec4"
+; $ATTRIB_VARS[1].location = 1
+; R3
+; $ATTRIB_VARS[2].name = "a_texcoord"
+; $ATTRIB_VARS[2].type = "vec2"
+; $ATTRIB_VARS[2].location = 2
+
+00 CALL_FS NO_BARRIER
+01 ALU: ADDR(32) CNT(14)
+    0  x: MUL    ____,   1.0f, C3.x
+       y: MUL    ____,   1.0f, C3.y
+       z: MUL    ____,   1.0f, C3.z
+       w: MUL    ____,   1.0f, C3.w
+    1  x: MULADD R127.x, R1.y, C1.x, PV0.x
+       y: MULADD R127.y, R1.y, C1.y, PV0.y
+       z: MULADD R127.z, R1.y, C1.z, PV0.z
+       w: MULADD R127.w, R1.y, C1.w, PV0.w
+    2  x: MULADD R1.x,   R1.x, C0.x, PV0.x
+       y: MULADD R1.y,   R1.x, C0.y, PV0.y
+       z: MULADD R1.z,   R1.x, C0.z, PV0.z
+       w: MULADD R1.w,   R1.x, C0.w, PV0.w
+02 EXP_DONE: POS0, R1
+03 EXP: PARAM0, R2 NO_BARRIER
+04 EXP_DONE: PARAM1, R3.xy00 NO_BARRIER
+END_OF_PROGRAM
diff --git a/src/stdlib/SDL_malloc.c b/src/stdlib/SDL_malloc.c
index c1aa44414..8c796fba7 100644
--- a/src/stdlib/SDL_malloc.c
+++ b/src/stdlib/SDL_malloc.c
@@ -512,6 +512,12 @@ DEFAULT_MMAP_THRESHOLD       default: 256K
 #define LACKS_SYS_MMAN_H
 #endif  /* __OS2__ */
 
+#ifdef __WIIU__
+#define HAVE_MMAP 0
+#define LACKS_SYS_MMAN_H
+#define USE_LOCKS 0 // TODO: use locks
+#endif /* __WIIU__ */
+
 #if defined(DARWIN) || defined(_DARWIN)
 /* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
 #ifndef HAVE_MORECORE
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 278a68026..754c43718 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -46,6 +46,8 @@
 #include "os2/SDL_systhread_c.h"
 #elif SDL_THREAD_NGAGE
 #include "ngage/SDL_systhread_c.h"
+#elif SDL_THREAD_WIIU
+#include "wiiu/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/wiiu/SDL_syscond.c b/src/thread/wiiu/SDL_syscond.c
new file mode 100644
index 000000000..318a50050
--- /dev/null
+++ b/src/thread/wiiu/SDL_syscond.c
@@ -0,0 +1,146 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+#include "SDL_thread.h"
+
+#include <stdbool.h>
+#include <coreinit/alarm.h>
+#include <coreinit/mutex.h>
+#include <coreinit/condition.h>
+
+typedef struct
+{
+   OSCondition *cond;
+   bool timed_out;
+} WIIU_CondWaitTimeoutData;
+
+/* Create a condition variable */
+SDL_cond *
+SDL_CreateCond(void)
+{
+    OSCondition *cond;
+
+    cond = (OSCondition *) SDL_malloc(sizeof(OSCondition));
+    if (cond) {
+        OSInitCond(cond);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return (SDL_cond *)cond;
+}
+
+/* Destroy a condition variable */
+void
+SDL_DestroyCond(SDL_cond * cond)
+{
+    if (cond) {
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int
+SDL_CondSignal(SDL_cond * cond)
+{
+    return SDL_CondBroadcast(cond);
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int
+SDL_CondBroadcast(SDL_cond * cond)
+{
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    OSSignalCond((OSCondition *)cond);
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+
+static void
+SDL_CondWaitTimeoutCallback(OSAlarm *alarm, OSContext *context)
+{
+   WIIU_CondWaitTimeoutData *data = (WIIU_CondWaitTimeoutData *)OSGetAlarmUserData(alarm);
+   data->timed_out = true;
+   OSSignalCond(data->cond);
+}
+
+int
+SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
+{
+	WIIU_CondWaitTimeoutData data;
+    OSAlarm alarm;
+
+	data.timed_out = false;
+	data.cond = (OSCondition *)cond;
+
+	// Timeout is zero
+	if (!ms)
+		return SDL_MUTEX_TIMEDOUT;
+
+	// Set an alarm
+	OSCreateAlarm(&alarm);
+	OSSetAlarmUserData(&alarm, &data);
+	OSSetAlarm(&alarm, OSMillisecondsToTicks(ms), &SDL_CondWaitTimeoutCallback);
+
+	// Wait on the condition
+	OSWaitCond((OSCondition *)cond, (OSMutex *)mutex);
+
+	OSCancelAlarm(&alarm);
+	return data.timed_out ? SDL_MUTEX_TIMEDOUT : 0;
+}
+
+/* Wait on the condition variable forever */
+int
+SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex)
+{
+    OSWaitCond((OSCondition *)cond, (OSMutex *)mutex);
+    return 0;
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/wiiu/SDL_sysmutex.c b/src/thread/wiiu/SDL_sysmutex.c
new file mode 100644
index 000000000..4d80b161e
--- /dev/null
+++ b/src/thread/wiiu/SDL_sysmutex.c
@@ -0,0 +1,88 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+#include <errno.h>
+#include <coreinit/mutex.h>
+#include "SDL_thread.h"
+
+
+SDL_mutex *
+SDL_CreateMutex(void)
+{
+    OSMutex *mutex;
+
+    /* Allocate the structure */
+    mutex = (OSMutex *) SDL_calloc(1, sizeof(OSMutex));
+    if (mutex != NULL) {
+        OSInitMutex(mutex);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return (SDL_mutex *)mutex;
+}
+
+void
+SDL_DestroyMutex(SDL_mutex * mutex)
+{
+    if (mutex != NULL) {
+        SDL_free(mutex);
+    }
+}
+
+/* Lock the mutex */
+int
+SDL_LockMutex(SDL_mutex * mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
+{
+    if (mutex == NULL) {
+        return 0;
+    }
+
+    OSLockMutex((OSMutex *)mutex);
+    return 0;
+}
+
+int
+SDL_TryLockMutex(SDL_mutex * mutex)
+{
+    if (mutex == NULL) {
+        return 0;
+    }
+
+    return OSTryLockMutex((OSMutex *)mutex) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+int
+SDL_UnlockMutex(SDL_mutex * mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
+{
+    if (mutex == NULL) {
+        return 0;
+    }
+
+    OSUnlockMutex((OSMutex *)mutex);
+    return 0;
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
\ No newline at end of file
diff --git a/src/thread/wiiu/SDL_sysmutex_c.h b/src/thread/wiiu/SDL_sysmutex_c.h
new file mode 100644
index 000000000..2979437b5
--- /dev/null
+++ b/src/thread/wiiu/SDL_sysmutex_c.h
@@ -0,0 +1,22 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/wiiu/SDL_syssem.c b/src/thread/wiiu/SDL_syssem.c
new file mode 100644
index 000000000..a0038aa87
--- /dev/null
+++ b/src/thread/wiiu/SDL_syssem.c
@@ -0,0 +1,145 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <coreinit/semaphore.h>
+#include <coreinit/condition.h>
+#include <coreinit/alarm.h>
+#include <coreinit/mutex.h>
+#include <coreinit/time.h>
+
+#include <stdbool.h>
+
+typedef struct
+{
+   OSCondition *cond;
+   bool timed_out;
+} WIIU_SemWaitTimeoutData;
+
+struct SDL_semaphore
+{
+	OSMutex mtx;
+	OSSemaphore sem;
+	OSCondition cond;
+};
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (sem) {
+        OSInitSemaphore(&sem->sem, initial_value);
+		OSInitMutex(&sem->mtx);
+		OSInitCond(&sem->cond);
+    } else {
+        SDL_OutOfMemory();
+    }
+
+    return sem;
+}
+
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+    if (sem) {
+        SDL_free(sem);
+    }
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    return (OSTryWaitSemaphore(&sem->sem) > 0) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+static void
+SDL_SemWaitTimeoutCallback(OSAlarm *alarm, OSContext *context)
+{
+   WIIU_SemWaitTimeoutData *data = (WIIU_SemWaitTimeoutData *)OSGetAlarmUserData(alarm);
+   data->timed_out = true;
+   OSSignalCond(data->cond);
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms)
+{
+	WIIU_SemWaitTimeoutData data;
+    OSAlarm alarm;
+
+	// timeout is zero
+	if (!ms)
+		SDL_SemTryWait(sem);
+
+	OSLockMutex(&sem->mtx);
+
+	// setup callback data
+	data.timed_out = false;
+	data.cond = &sem->cond;
+
+	// set an alarm
+	OSCreateAlarm(&alarm);
+	OSSetAlarmUserData(&alarm, &data);
+	OSSetAlarm(&alarm, OSMillisecondsToTicks(ms), &SDL_SemWaitTimeoutCallback);
+
+	// try to acquire the semaphore
+    while((OSTryWaitSemaphore(&sem->sem) <= 0) && (data.timed_out == false)) {
+		OSWaitCond(&sem->cond, &sem->mtx);
+    }
+
+	OSCancelAlarm(&alarm);
+
+	OSUnlockMutex(&sem->mtx);
+
+    return (data.timed_out == false) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    OSWaitSemaphore(&sem->sem);
+    return 0;
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    return OSGetSemaphoreCount(&sem->sem);
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+	OSSignalSemaphore(&sem->sem);
+	OSSignalCond(&sem->cond);
+    return 0;
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/wiiu/SDL_systhread.c b/src/thread/wiiu/SDL_systhread.c
new file mode 100644
index 000000000..e2904e119
--- /dev/null
+++ b/src/thread/wiiu/SDL_systhread.c
@@ -0,0 +1,121 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+/* WiiU thread management routines for SDL */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+#include <malloc.h>
+#include <coreinit/thread.h>
+
+static void
+thread_deallocator(OSThread *thread, void *stack)
+{
+   free(thread);
+   free(stack);
+}
+
+static void
+thread_cleanup(OSThread *thread, void *stack)
+{
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread)
+{
+    OSThread *handle = (OSThread *)memalign(16, sizeof(OSThread));
+    unsigned int stackSize = thread->stacksize ? thread->stacksize : 0x8000;
+    void *stackTop = memalign(16, stackSize) + stackSize;
+    int priority = OSGetThreadPriority(OSGetCurrentThread());
+
+    if (!OSCreateThread(handle,
+                        (OSThreadEntryPointFn)SDL_RunThread,
+                        (int32_t)thread,
+                        NULL,
+                        stackTop,
+                        stackSize,
+                        priority,
+                        OS_THREAD_ATTRIB_AFFINITY_ANY))
+    {
+        return SDL_SetError("OSCreateThread() failed");
+    }
+
+    OSSetThreadDeallocator(handle, &thread_deallocator);
+    OSSetThreadCleanupCallback(handle, &thread_cleanup);
+    OSResumeThread(handle);
+    thread->handle = handle;
+    return 0;
+}
+
+void SDL_SYS_SetupThread(const char *name)
+{
+    OSSetThreadName(OSGetCurrentThread(), name);
+}
+
+SDL_threadID SDL_ThreadID(void)
+{
+    return (SDL_threadID) OSGetCurrentThread();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+    OSJoinThread(thread->handle, NULL);
+}
+
+void SDL_SYS_DetachThread(SDL_Thread *thread)
+{
+    OSDetachThread(thread->handle);
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+    OSCancelThread(thread->handle);
+}
+
+int SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    int value;
+
+    if (priority == SDL_THREAD_PRIORITY_LOW) {
+        value = 17;
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        value = 15;
+    } else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
+        value = 14;
+    } else {
+        value = 16;
+    }
+
+    return OSSetThreadPriority(OSGetCurrentThread(), value);
+
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vim: ts=4 sw=4
+ */
\ No newline at end of file
diff --git a/src/thread/wiiu/SDL_systhread_c.h b/src/thread/wiiu/SDL_systhread_c.h
new file mode 100644
index 000000000..ca0626101
--- /dev/null
+++ b/src/thread/wiiu/SDL_systhread_c.h
@@ -0,0 +1,27 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include <coreinit/thread.h>
+
+typedef OSThread *SYS_ThreadHandle;
+
+/* vi: set ts=4 sw=4 expandtab: */
\ No newline at end of file
diff --git a/src/timer/wiiu/SDL_systimer.c b/src/timer/wiiu/SDL_systimer.c
new file mode 100644
index 000000000..13c5257f2
--- /dev/null
+++ b/src/timer/wiiu/SDL_systimer.c
@@ -0,0 +1,86 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_TIMER_WIIU
+
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "SDL_error.h"
+#include "../SDL_timer_c.h"
+#include <coreinit/thread.h>
+#include <coreinit/systeminfo.h>
+#include <coreinit/time.h>
+
+static OSTime start;
+static SDL_bool ticks_started = SDL_FALSE;
+
+void
+SDL_TicksInit(void)
+{
+    if (ticks_started) {
+        return;
+    }
+    ticks_started = SDL_TRUE;
+    start = OSGetSystemTime();
+}
+
+void
+SDL_TicksQuit(void)
+{
+    ticks_started = SDL_FALSE;
+}
+
+Uint64
+SDL_GetTicks64(void)
+{
+    OSTime now;
+
+    if (!ticks_started) {
+        SDL_TicksInit();
+    }
+
+    now = OSGetSystemTime();
+    return (Uint64)OSTicksToMilliseconds(now - start);
+}
+
+Uint64
+SDL_GetPerformanceCounter(void)
+{
+    return OSGetTime();
+}
+
+Uint64
+SDL_GetPerformanceFrequency(void)
+{
+    return OSTimerClockSpeed;
+}
+
+void
+SDL_Delay(Uint32 ms)
+{
+   OSSleepTicks(OSMillisecondsToTicks(ms));
+}
+
+#endif /* SDL_TIMER_WIIU */
+
+/* vim: ts=4 sw=4
+ */
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index d7a42cc64..0d88ea5e6 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -482,6 +482,7 @@ extern VideoBootStrap OFFSCREEN_bootstrap;
 extern VideoBootStrap NGAGE_bootstrap;
 extern VideoBootStrap OS2DIVE_bootstrap;
 extern VideoBootStrap OS2VMAN_bootstrap;
+extern VideoBootStrap WIIU_bootstrap;
 
 /* Use SDL_OnVideoThread() sparingly, to avoid regressions in use cases that currently happen to work */
 extern SDL_bool SDL_OnVideoThread(void);
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 8065a0b8c..929fd231a 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -132,6 +132,12 @@ static VideoBootStrap *bootstrap[] = {
     &OS2DIVE_bootstrap,
     &OS2VMAN_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_WIIU
+    &WIIU_bootstrap,
+#endif
+#if SDL_VIDEO_DRIVER_OFFSCREEN
+    &OFFSCREEN_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_NGAGE
     &NGAGE_bootstrap,
 #endif
@@ -1511,7 +1517,7 @@ static int SDL_UpdateFullscreenMode(SDL_Window *window, SDL_bool fullscreen)
 }
 
 #define CREATE_FLAGS \
-    (SDL_WINDOW_OPENGL | SDL_WINDOW_BORDERLESS | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_ALWAYS_ON_TOP | SDL_WINDOW_SKIP_TASKBAR | SDL_WINDOW_POPUP_MENU | SDL_WINDOW_UTILITY | SDL_WINDOW_TOOLTIP | SDL_WINDOW_VULKAN | SDL_WINDOW_MINIMIZED | SDL_WINDOW_METAL)
+    (SDL_WINDOW_OPENGL | SDL_WINDOW_BORDERLESS | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_ALWAYS_ON_TOP | SDL_WINDOW_SKIP_TASKBAR | SDL_WINDOW_POPUP_MENU | SDL_WINDOW_UTILITY | SDL_WINDOW_TOOLTIP | SDL_WINDOW_VULKAN | SDL_WINDOW_MINIMIZED | SDL_WINDOW_METAL | SDL_WINDOW_WIIU_GAMEPAD_ONLY | SDL_WINDOW_WIIU_TV_ONLY)
 
 static SDL_INLINE SDL_bool IsAcceptingDragAndDrop(void)
 {
diff --git a/src/video/wiiu/SDL_wiiu_gfx_heap.c b/src/video/wiiu/SDL_wiiu_gfx_heap.c
new file mode 100644
index 000000000..5e77367c7
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiu_gfx_heap.c
@@ -0,0 +1,203 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (c) 2015-present devkitPro, wut Authors
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_WIIU
+
+#include "SDL_wiiu_gfx_heap.h"
+
+#include <stdio.h>
+#include <malloc.h>
+
+#include <coreinit/memheap.h>
+#include <coreinit/memdefaultheap.h>
+#include <coreinit/memexpheap.h>
+#include <coreinit/memfrmheap.h>
+
+#define FRM_HEAP_STATE_TAG 0x53444C32 // 'SDL2'
+
+static MEMHeapHandle GfxHeap_MEM1 = NULL;
+static MEMHeapHandle GfxHeap_Foreground = NULL;
+
+int WIIU_GfxHeap_MEM1Init(void)
+{
+    MEMHeapHandle heap = MEMGetBaseHeapHandle(MEM_BASE_HEAP_MEM1);
+    uint32_t size;
+    void *base;
+
+    if (!MEMRecordStateForFrmHeap(heap, FRM_HEAP_STATE_TAG)) {
+        printf("%s: MEMRecordStateForFrmHeap failed\n", __FUNCTION__);
+        return -1;
+    }
+
+    size = MEMGetAllocatableSizeForFrmHeapEx(heap, 4);
+    if (!size) {
+        printf("%s: MEMGetAllocatableSizeForFrmHeapEx == 0\n", __FUNCTION__);
+        return -1;
+    }
+
+    base = MEMAllocFromFrmHeapEx(heap, size, 4);
+    if (!base) {
+        printf("%s: MEMAllocFromFrmHeapEx(heap, 0x%X, 4) failed\n", __FUNCTION__, size);
+        return -1;
+    }
+
+    GfxHeap_MEM1 = MEMCreateExpHeapEx(base, size, 0);
+    if (!GfxHeap_MEM1) {
+        printf("%s: MEMCreateExpHeapEx(%p, 0x%X, 0) failed\n", __FUNCTION__, base, size);
+        return -1;
+    }
+
+   return 0;
+}
+
+int WIIU_GfxHeap_MEM1Destroy(void)
+{
+    MEMHeapHandle heap = MEMGetBaseHeapHandle(MEM_BASE_HEAP_MEM1);
+
+    if (GfxHeap_MEM1) {
+        MEMDestroyExpHeap(GfxHeap_MEM1);
+        GfxHeap_MEM1 = NULL;
+    }
+
+    MEMFreeByStateToFrmHeap(heap, FRM_HEAP_STATE_TAG);
+    return 0;
+}
+
+int WIIU_GfxHeap_ForegroundInit(void)
+{
+    MEMHeapHandle heap = MEMGetBaseHeapHandle(MEM_BASE_HEAP_FG);
+    uint32_t size;
+    void *base;
+
+    size = MEMGetAllocatableSizeForFrmHeapEx(heap, 4);
+    if (!size) {
+        printf("%s: MEMAllocFromFrmHeapEx(heap, 0x%X, 4)\n", __FUNCTION__, size);
+        return -1;
+    }
+
+    base = MEMAllocFromFrmHeapEx(heap, size, 4);
+    if (!base) {
+        printf("%s: MEMGetAllocatableSizeForFrmHeapEx == 0\n", __FUNCTION__);
+        return -1;
+    }
+
+    GfxHeap_Foreground = MEMCreateExpHeapEx(base, size, 0);
+    if (!GfxHeap_Foreground) {
+        printf("%s: MEMCreateExpHeapEx(%p, 0x%X, 0)\n", __FUNCTION__, base, size);
+        return -1;
+    }
+
+    return 0;
+}
+
+int WIIU_GfxHeap_ForegroundDestroy(void)
+{
+    MEMHeapHandle foreground = MEMGetBaseHeapHandle(MEM_BASE_HEAP_FG);
+
+    if (GfxHeap_Foreground) {
+        MEMDestroyExpHeap(GfxHeap_Foreground);
+        GfxHeap_Foreground = NULL;
+    }
+
+    MEMFreeToFrmHeap(foreground, MEM_FRM_HEAP_FREE_ALL);
+    return 0;
+}
+
+void *WIIU_GfxHeap_MEM1Alloc(uint32_t align, uint32_t size)
+{
+    void *block;
+
+    if (!GfxHeap_MEM1) {
+        return NULL;
+    }
+
+    if (align < 4) {
+        align = 4;
+    }
+
+    block = MEMAllocFromExpHeapEx(GfxHeap_MEM1, size, align);
+    return block;
+}
+
+void WIIU_GfxHeap_MEM1Free(void *block)
+{
+    if (!GfxHeap_MEM1) {
+        return;
+    }
+
+    MEMFreeToExpHeap(GfxHeap_MEM1, block);
+}
+
+void *WIIU_GfxHeap_ForegroundAlloc(uint32_t align, uint32_t size)
+{
+    void *block;
+
+    if (!GfxHeap_Foreground) {
+        return NULL;
+    }
+
+    if (align < 4) {
+        align = 4;
+    }
+
+    block = MEMAllocFromExpHeapEx(GfxHeap_Foreground, size, align);
+    return block;
+}
+
+void WIIU_GfxHeap_ForegroundFree(void *block)
+{
+    if (!GfxHeap_Foreground) {
+        return;
+    }
+
+    MEMFreeToExpHeap(GfxHeap_Foreground, block);
+}
+
+void *WIIU_GfxHeap_GX2RAlloc(GX2RResourceFlags flags, uint32_t size, uint32_t alignment)
+{
+    // Color, depth, scan buffers all belong in MEM1
+    if ((flags & (GX2R_RESOURCE_BIND_COLOR_BUFFER
+                | GX2R_RESOURCE_BIND_DEPTH_BUFFER
+                | GX2R_RESOURCE_BIND_SCAN_BUFFER
+                | GX2R_RESOURCE_USAGE_FORCE_MEM1))
+        && !(flags & GX2R_RESOURCE_USAGE_FORCE_MEM2)) {
+        return WIIU_GfxHeap_MEM1Alloc(alignment, size);
+    } else {
+        return memalign(alignment, size);
+    }
+}
+
+void WIIU_GfxHeap_GX2RFree(GX2RResourceFlags flags, void *block)
+{
+    if ((flags & (GX2R_RESOURCE_BIND_COLOR_BUFFER
+                | GX2R_RESOURCE_BIND_DEPTH_BUFFER
+                | GX2R_RESOURCE_BIND_SCAN_BUFFER
+                | GX2R_RESOURCE_USAGE_FORCE_MEM1))
+        && !(flags & GX2R_RESOURCE_USAGE_FORCE_MEM2)) {
+        return WIIU_GfxHeap_MEM1Free(block);
+    } else {
+        return free(block);
+    }
+}
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
diff --git a/src/video/wiiu/SDL_wiiu_gfx_heap.h b/src/video/wiiu/SDL_wiiu_gfx_heap.h
new file mode 100644
index 000000000..373913ada
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiu_gfx_heap.h
@@ -0,0 +1,53 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (c) 2015-present devkitPro, wut Authors
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_wiiu_gfx_heap_h
+#define SDL_wiiu_gfx_heap_h
+
+#if SDL_VIDEO_DRIVER_WIIU
+
+#include <gx2r/mem.h>
+
+int WIIU_GfxHeap_MEM1Init(void);
+
+int WIIU_GfxHeap_MEM1Destroy(void);
+
+int WIIU_GfxHeap_ForegroundInit(void);
+
+int WIIU_GfxHeap_ForegroundDestroy(void);
+
+void *WIIU_GfxHeap_MEM1Alloc(uint32_t align, uint32_t size);
+
+void WIIU_GfxHeap_MEM1Free(void *block);
+
+void *WIIU_GfxHeap_ForegroundAlloc(uint32_t align, uint32_t size);
+
+void WIIU_GfxHeap_ForegroundFree(void *block);
+
+void *WIIU_GfxHeap_GX2RAlloc(GX2RResourceFlags flags, uint32_t size, uint32_t alignment);
+
+void WIIU_GfxHeap_GX2RFree(GX2RResourceFlags flags, void *block);
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
+
+#endif /* SDL_wiiu_gfx_heap_h */
diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
new file mode 100644
index 000000000..f42f206aa
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -0,0 +1,387 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2018 rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_WIIU
+
+/* SDL internals */
+#include "../SDL_sysvideo.h"
+#include "SDL_version.h"
+#include "SDL_syswm.h"
+#include "SDL_loadso.h"
+#include "SDL_events.h"
+#include "SDL_render.h"
+#include "../../events/SDL_mouse_c.h"
+#include "../../events/SDL_keyboard_c.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_wiiuvideo.h"
+#include "SDL_wiiu_gfx_heap.h"
+
+#include "../../render/wiiu/SDL_render_wiiu.h"
+
+#include <stdio.h>
+#include <malloc.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <coreinit/foreground.h>
+#include <proc_ui/procui.h>
+
+#include <gx2/context.h>
+#include <gx2/display.h>
+#include <gx2/event.h>
+#include <gx2/mem.h>
+#include <gx2/state.h>
+#include <gx2r/mem.h>
+#include <gx2r/surface.h>
+
+#define DRC_SCREEN_WIDTH    854
+#define DRC_SCREEN_HEIGHT   480
+
+static SDL_bool running = SDL_FALSE;
+
+static int WIIU_ForegroundAcquired(_THIS)
+{
+	WIIU_VideoData *videodata;
+	SDL_Window* window;
+
+	if (!running) {
+		return 0;
+	}
+
+	videodata = (WIIU_VideoData *) _this->driverdata;
+	window = _this->windows;
+	videodata->hasForeground = SDL_TRUE;
+
+	// initialize gfx heaps once in forground
+	if (WIIU_GfxHeap_ForegroundInit() != 0) {
+		return -1;
+	}
+
+	if (WIIU_GfxHeap_MEM1Init() != 0) {
+		return -1;
+	}
+
+	// allocate and set scanbuffers
+	videodata->tvScanBuffer = WIIU_GfxHeap_ForegroundAlloc(GX2_SCAN_BUFFER_ALIGNMENT, videodata->tvScanBufferSize);
+	if (!videodata->tvScanBuffer) {
+		return -1;
+	}
+
+	GX2Invalidate(GX2_INVALIDATE_MODE_CPU, videodata->tvScanBuffer, videodata->tvScanBufferSize);
+	GX2SetTVBuffer(videodata->tvScanBuffer, videodata->tvScanBufferSize, videodata->tvRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE);
+
+	videodata->drcScanBuffer = WIIU_GfxHeap_ForegroundAlloc(GX2_SCAN_BUFFER_ALIGNMENT, videodata->drcScanBufferSize);
+	if (!videodata->drcScanBuffer) {
+		return -1;
+	}
+
+	GX2Invalidate(GX2_INVALIDATE_MODE_CPU, videodata->drcScanBuffer, videodata->drcScanBufferSize);
+	GX2SetDRCBuffer(videodata->drcScanBuffer, videodata->drcScanBufferSize, videodata->drcRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE);
+
+	while (window) {
+		SDL_Renderer* renderer = SDL_GetRenderer(window);
+
+		// Recreate the window texture, now that we have foreground memory available
+		if (renderer) {
+			WIIU_SDL_CreateWindowTex(renderer, window);
+		}
+
+		// We're now in foreground, window is visible
+		SDL_SendWindowEvent(window, SDL_WINDOWEVENT_SHOWN, 0, 0);
+
+		window = window->next;
+	}
+
+	return 0;
+}
+
+static int WIIU_ForegroundReleased(_THIS)
+{
+	WIIU_VideoData *videodata;
+	SDL_Window* window;
+
+	if (!running) {
+		return 0;
+	}
+
+	videodata = (WIIU_VideoData *) _this->driverdata;
+	window = _this->windows;
+
+	// make sure the GPU is done drawing
+	GX2DrawDone();
+
+	if (videodata->tvScanBuffer) {
+		WIIU_GfxHeap_ForegroundFree(videodata->tvScanBuffer);
+		videodata->tvScanBuffer = NULL;
+	}
+
+	if (videodata->drcScanBuffer) {
+		WIIU_GfxHeap_ForegroundFree(videodata->drcScanBuffer);
+		videodata->drcScanBuffer = NULL;
+	}
+
+	while (window) {
+		SDL_Renderer* renderer = SDL_GetRenderer(window);
+
+		// No longer in foreground, window is no longer visible
+		SDL_SendWindowEvent(window, SDL_WINDOWEVENT_HIDDEN, 0, 0);
+
+		// Destroy window texture, we no longer have access to foreground memory
+		if (renderer) {
+			// TODO this causes crashes on exit for some reason?
+			// Doesn't matter since we destroy the heap anyways ¯\_(ツ)_/¯
+			//WIIU_SDL_DestroyWindowTex(renderer, window);
+		}
+
+		window = window->next;
+	}
+
+	WIIU_GfxHeap_MEM1Destroy();
+	WIIU_GfxHeap_ForegroundDestroy();
+
+	// This is necessary to avoid a black frame on leaving foreground
+	GX2SetTVEnable(TRUE);
+	GX2SetDRCEnable(TRUE);
+
+	videodata->hasForeground = SDL_FALSE;
+
+	return 0;
+}
+
+static uint32_t WiiU_SaveCallback(void * arg)
+{
+	OSSavesDone_ReadyToRelease();
+	return 0;
+}
+
+static int WIIU_VideoInit(_THIS)
+{
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+	uint32_t unk;
+	SDL_DisplayMode mode;
+	uint32_t* initAttribs;
+
+	// check if the user already set up procui or if we should handle it
+	if (!ProcUIIsRunning()) {
+		ProcUIInitEx(WiiU_SaveCallback, NULL);
+		
+		videodata->handleProcUI = SDL_TRUE;
+	}
+
+	// allocate command buffer pool
+	videodata->commandBufferPool = memalign(GX2_COMMAND_BUFFER_ALIGNMENT, GX2_COMMAND_BUFFER_SIZE);
+	if (!videodata->commandBufferPool) {
+		return SDL_OutOfMemory();
+	}
+
+	// initialize GX2
+	initAttribs = (uint32_t[]) {
+		GX2_INIT_CMD_BUF_BASE, (uintptr_t) videodata->commandBufferPool,
+		GX2_INIT_CMD_BUF_POOL_SIZE, GX2_COMMAND_BUFFER_SIZE,
+		GX2_INIT_ARGC, 0,
+		GX2_INIT_ARGV, 0,
+		GX2_INIT_END
+	};
+	GX2Init(initAttribs);
+
+	// figure out the TV render mode and size
+	switch(GX2GetSystemTVScanMode()) {
+	case GX2_TV_SCAN_MODE_480I:
+	case GX2_TV_SCAN_MODE_480P:
+		videodata->tvRenderMode = GX2_TV_RENDER_MODE_WIDE_480P;
+		videodata->tvWidth = 854;
+		videodata->tvHeight = 480;
+		break;
+	case GX2_TV_SCAN_MODE_1080I:
+	case GX2_TV_SCAN_MODE_1080P:
+		videodata->tvRenderMode = GX2_TV_RENDER_MODE_WIDE_1080P;
+		videodata->tvWidth = 1920;
+		videodata->tvHeight = 1080;
+		break;
+	case GX2_TV_SCAN_MODE_720P:
+	default:
+		videodata->tvRenderMode = GX2_TV_RENDER_MODE_WIDE_720P;
+		videodata->tvWidth = 1280;
+		videodata->tvHeight = 720;
+		break;
+	}
+
+	videodata->drcRenderMode = GX2GetSystemDRCScanMode();
+
+	// calculate the scanbuffer sizes
+	GX2CalcTVSize(videodata->tvRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE, &videodata->tvScanBufferSize, &unk);
+	GX2CalcDRCSize(videodata->drcRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE, &videodata->drcScanBufferSize, &unk);
+
+	// set GX2R allocator for the gfx heap
+	GX2RSetAllocator(&WIIU_GfxHeap_GX2RAlloc, &WIIU_GfxHeap_GX2RFree);
+
+	// register callbacks for acquiring and releasing foreground
+	ProcUIRegisterCallback(PROCUI_CALLBACK_ACQUIRE, (ProcUICallback) WIIU_ForegroundAcquired, _this, 100);
+	ProcUIRegisterCallback(PROCUI_CALLBACK_RELEASE, (ProcUICallback) WIIU_ForegroundReleased, _this, 100);
+
+	running = SDL_TRUE;
+
+	// if this is running, the application is already in foreground so call the callback
+	if (WIIU_ForegroundAcquired(_this) != 0) {
+		free(videodata->commandBufferPool);
+		videodata->commandBufferPool = NULL;
+		return SDL_OutOfMemory();
+	}
+
+	GX2SetTVScale(videodata->tvWidth, videodata->tvHeight);
+	GX2SetDRCScale(DRC_SCREEN_WIDTH, DRC_SCREEN_HEIGHT);
+
+	// add tv display
+	SDL_zero(mode);
+	mode.format = SDL_PIXELFORMAT_RGBA8888;
+	mode.w = videodata->tvWidth;
+	mode.h = videodata->tvHeight;
+	mode.refresh_rate = 60;
+	SDL_AddBasicVideoDisplay(&mode);
+
+	// add drc display
+	SDL_zero(mode);
+	mode.format = SDL_PIXELFORMAT_RGBA8888;
+	mode.w = DRC_SCREEN_WIDTH;
+	mode.h = DRC_SCREEN_HEIGHT;
+	mode.refresh_rate = 60;
+	SDL_AddBasicVideoDisplay(&mode);
+
+	return 0;
+}
+
+static void WIIU_VideoQuit(_THIS)
+{
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+
+	// if we're in foreground, destroy foreground data
+	if (videodata->hasForeground) {
+		WIIU_ForegroundReleased(_this);
+	}
+
+	// shutdown GX2 and free command buffer
+	GX2Shutdown();
+
+	if (videodata->commandBufferPool) {
+		free(videodata->commandBufferPool);
+		videodata->commandBufferPool = NULL;
+	}
+
+	if (videodata->handleProcUI) {
+		ProcUIShutdown();
+	}
+
+	running = SDL_FALSE;
+}
+
+static int WIIU_CreateSDLWindow(_THIS, SDL_Window * window)
+{
+	// focus the window
+	SDL_SetMouseFocus(window);
+	SDL_SetKeyboardFocus(window);
+	return 0;
+}
+
+static void WIIU_SetWindowSize(_THIS, SDL_Window * window)
+{
+}
+
+static void WIIU_DestroyWindow(_THIS, SDL_Window * window)
+{
+}
+
+static void WIIU_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
+{
+	// we currently only have one mode per display, which is the current one
+	SDL_AddDisplayMode(display, &display->current_mode);
+}
+
+static int WIIU_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode)
+{
+	return 0;
+}
+
+static void WIIU_PumpEvents(_THIS)
+{
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+
+	if (videodata->handleProcUI) {
+		ProcUIStatus status = ProcUIProcessMessages(TRUE);
+		if (status == PROCUI_STATUS_EXITING) {
+			SDL_SendQuit();
+		} else if (status == PROCUI_STATUS_RELEASE_FOREGROUND) {
+			ProcUIDrawDoneRelease();
+		}
+	}
+}
+
+static void WIIU_DeleteDevice(SDL_VideoDevice *device)
+{
+	SDL_free(device->driverdata);
+	SDL_free(device);
+}
+
+static SDL_VideoDevice *WIIU_CreateDevice(void)
+{
+	SDL_VideoDevice *device;
+	WIIU_VideoData *videodata;
+
+	device = (SDL_VideoDevice*) SDL_calloc(1, sizeof(SDL_VideoDevice));
+	if(!device) {
+		SDL_OutOfMemory();
+		return NULL;
+	}
+
+	videodata = (WIIU_VideoData*) SDL_calloc(1, sizeof(WIIU_VideoData));
+	if(!videodata) {
+		SDL_OutOfMemory();
+		return NULL;
+	}
+
+	device->driverdata = videodata;
+
+	// Setup amount of available displays
+	device->num_displays = 0;
+
+	device->VideoInit = WIIU_VideoInit;
+	device->VideoQuit = WIIU_VideoQuit;
+	device->CreateSDLWindow = WIIU_CreateSDLWindow;
+	device->SetWindowSize = WIIU_SetWindowSize;
+	device->DestroyWindow = WIIU_DestroyWindow;
+	device->GetDisplayModes = WIIU_GetDisplayModes;
+	device->SetDisplayMode = WIIU_SetDisplayMode;
+	device->PumpEvents = WIIU_PumpEvents;
+
+	device->free = WIIU_DeleteDevice;
+
+	return device;
+}
+
+VideoBootStrap WIIU_bootstrap = {
+	"WiiU", "Video driver for Nintendo WiiU",
+	WIIU_CreateDevice
+};
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
diff --git a/src/video/wiiu/SDL_wiiuvideo.h b/src/video/wiiu/SDL_wiiuvideo.h
new file mode 100644
index 000000000..a635012d9
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiuvideo.h
@@ -0,0 +1,57 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifndef SDL_wiiuvideo_h
+#define SDL_wiiuvideo_h
+
+#if SDL_VIDEO_DRIVER_WIIU
+
+#include <gx2/surface.h>
+
+typedef struct WIIU_VideoData WIIU_VideoData;
+
+struct WIIU_VideoData
+{
+	// indicate if we're handling procui in SDL's events
+	SDL_bool handleProcUI;
+
+	SDL_bool hasForeground;
+
+	void *commandBufferPool;
+
+	GX2TVRenderMode tvRenderMode;
+	uint32_t tvWidth;
+	uint32_t tvHeight;
+	void *tvScanBuffer;
+	uint32_t tvScanBufferSize;
+
+	GX2DrcRenderMode drcRenderMode;
+	void *drcScanBuffer;
+	uint32_t drcScanBufferSize;
+};
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
+
+#endif /* SDL_wiiuvideo_h */
